;                                                                                                                                &                          
;                                                                                                                                                             
;                                                                                                                                    #@                         
;       &@@@*                                                                                                                        ,&@                        
;       @@@@@@@.                                                   .*(((((((((((((*.   %@@                                            &&%                       
;       @@@@@@@@@@.                                        .//(((((((((((((((((((((((((&@@@@                                          &&&,                      
;      @@@@@@@@@@@@@@                                  /(((((((((((((/*...    ...*(((((#@@@@@#((.                                     &&&@                      
;     %@@@@@@@@@@@@@@@@@.                          /(((((/(((.                          @@@@@@@/((((                                  &&&&*                     
;     @@@@@@@@@@@@@@@@@@@@@.                    /(((((((.                               @@@@@@@@(((((((                               &&&&&                     
;     @@@@@@@@@@@@@@@@@@@@@@@@@              .((((((.                                   @@@@@@@@@  .((((((        .                   &&&&&&                    
;    ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        ((((((.                                      @@@@@@@@@@     (((((.     &,                  #&&&&&.                   
;     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  /((((*             ,&@@@#                      @@@@@@@@@@@      /((((.  .&(                  #&&&&&&                   
;     .# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#.         ,@@@@@@@@@@@@@@@@@.              @@@@@@@@@@@@@       *(((( &                  ,&&&&&@                   
;          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*         @@@@@@@@@@@@@@@        *(((&                  ,&&&&&@@                  
;  ,        &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@@@@@@@@@@@@@@@@@@@%         (&&&&                  ,&&&&&&&.                 
; @@(,        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         ,&&&&/                 ,&&&&&&&@                 
; @@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        &&&&&((                ,&&&&&&&@                 
; @@@@@@#       &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@       ,&&&&%(((               ,&&&&&&&                
; %@@@@@@@@@     .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      &&&&((((              ,&&&&&&&&&                
;  *@@@@@@@@@@@.   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.    %&&&&&, ((((             ,&&&&&&&&&,               
;     @@@@@@@@@@@@# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   *&&&&&&   (((/            #&&&&&&&&&@               
;       &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&&&&   *(((.           #&&&&&&&&&&               
;          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&    ((((           &&&&&&&&&&&               
;            @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(((*          &&&&&&&&&&&,              
;              *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*      &&&&&&&&&&&*              
;                *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%&@@@@@@@@@/@@@@@@@@@@@@@&..((((.        ,&&&&&&&&&&              
;                   @@@@@@@@@@@@@@@@@@@@,,/ @@@@@/& @@@@& #  @@@@@.  @@@%  .@@@@@@@(  .&@@@*@@@@/ %@@# @@@@@@@@@@@@@@@@@@@@((        %&&&&&&&&&&&@              
;                     @@@@@@@@@@@@@@@@@@@@ @@@@@@ @@@@ @@@@@# @@@@ #@@@@@ @@@@@@@@@@ @@@@@&&@@@ @@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@.    &&&&&&&&&&&&@              
;                       @@@@@@@@@@@@@@@@@& @@@@ @@@& @@@@@@@ @@@% @@@@@, @@@@@@@@@* (,. @@@@@@@. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&&&&&&&&&@              
;                         @@@@@@@@@@@@@@@.(@@ @@@@. @@@@@@@ @@@. @@@@@ ,@@@@@@@@@ (@@@ @@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&&&&              
;                         *&@@@@@@@@@@@@@ @%/@@@@@ @@@@@@/&@@@ .@@@@@ /@@@@@@ @@ %@@@@@@*&@@.@@@@@.*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@              
;                         .((@@@@@@@@@@@@  @@@@@@@ %@@#,@@@@@. . @@@  . .*(.&@@  *  ,/( @@/ @@@@@/%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#              
;                          ((((@@@@@@@@@@%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@&@@@@@@@@.@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&           
;                          (((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        
;                          (((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*     
;                          *(((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   ,#%@@@@@*  
;                           ((((((((&@@,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           
;                           /(((((((((@,  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        
;                            ((((((((((%   #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      
;                            (((((((((((((   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&((((((((&&&&&&&&&&&&&&&&&@@@@@@@@@@@@@@@@@    
;                            .(((((((((((((*  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%((((((((((((@&&&&&&&&&&&&&&&&&&%     .&@@@@@@@@@@   
;                             (((((((((((((((/  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&    /(((((((((((@&@&&&&&&&&&&&&&&&&@.             #@@@@@  
;                             *((((((((((((((((( *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.    .(((((((((((#&&&&&&&&&&&&&&&&&&&&&                    ,@.
;                              ((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*    .((((((((((((@&&&&&&&&&&&&&&&&&&&&&,                        
;                              ((((((((((((((((((((/@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*   *((((((((((((&&@&&&&&&&&&&&&&&&&&&&&@                          
;                              .(((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@./(((((((((((((&&&&&&&&&&&&&&&&&&&&&&&@&                            
;                               ((((((.(((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@((((((((((((%@@&&&&&&&&&&&&&&&&&&&&&&@&                              
;                               *(((((  *((((((((((((((@@@@@@@#(@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((#@@&&&&&&&&&&&&&&&&&&&&&&&&&                                 
;                                ((((*    /(((((((((((((@@@@@@(((@@@@@@@@@@@@@@@@@@@@@@@@((((((#&@&&&&&&&&&&&&&&&&&&&&&&&&@@(                                   
;                                /(((.      /(((((((((((&@@@@#((((@@@@@@@@@@@@@@@@@@@@@@(((&@&&&&&&&&&&&&&&&&&&&&&&&&&&@&*                                      
;                                 (((        (((((((((((/@@@@((((((@@@@@@@@@@@@@@@@@@@@@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%(.                                        
;                                 (((        .(((((((((((&@@&(((((((#@@@@@@@@@@@@@@@@@@&&&&&&&&&&&&&&&&&&&&&&&@&&%  (((                                         
;                                 .((         ((((((((((((@@((((((((((@@@@@@@@@@@@@@@@@&&&&&&&&&&&&&&&&&&&&&%       .((                                         
;                                  (/          (((((((((((@&(((((((((#&@@@@@@@@@@@@@@@&&&&&&&&&&&&&&&&&%.            (/                                         
;                                  /*          *(((((((((((((/ ,&&@&&&@@@@@@@@@@@@@@&@&&&&&&@&@&((((((              .                                         
;                                  ..           /(((((((/(&&&&&&&&&&&&&&&@@@@@@@@@@@&@@&&%,((((((((((((.              .                                         
;                                               .((#&@@&&&&&&&&&&&&&&&&&&@@@@@@@@@@(       ((((((((((((                                                         
;                                            .&@&@@&&&&&&&@@@&&&&&@@&%(((((@@@@@@@((       .((((((((((*                                                         
;                                      (&@@@@&&@@&@&%#((((((*      *((((((((@@@@@((.        ((((((((((                                                          
;                                                 *(((((((((.       /((((((((@@@&((         /((((((((.                                                          
;                                                  (((((((((        *((((((((#@@(((          ((((((((                                                           
;                                                  .((((((//         /((((((((@(((*          (((((((.                                                           
;                                                   /((((((.         (((((((((((((           .((((((                                                            
;                                                    ((((((          .((((((((((((            (((((/                                                            
;                                                    .((((/           (((((((((((*            *((((                                                             
;                                                     ((((.           .((((((((((.             (((*                                                             
;                                                      (((             ((((((((((              /((                                                              
;                                                      /((             .(((((((((               (*                                                              
;                                                       (*              ((((((((*               (                                                               
;                                                       .               .(((((((.                                                                               
;                                                                        (((((((                                                                                
;                                                                        /(((((/                                                                                
;                                                                         (((((.                                                                                
;                                                                         (((((                                                                                 
;                                                                         .((((                                                                                 
;                                                                          (((*                                                                                 
;                                                                          .((                                                                                  
;                                                                           ((                                                                                  
;                                                                           .*                                                                                  
                                                                                                                                                      
                                                        




#SingleInstance Force
CoordMode, relative
SetMousedelay, -1
SetKeydelay, -1		
SetControlDelay, -1

gosub Declarations

;~ Winactivate, Hyperspace
;~ Winwaitactive, Hyperspace
;~ Sleep, 500

	gosub OCR	
	msgbox % ocrText
	return



;~ imagesearch, x, y, 0, 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\Autohotkey\Tapestry\Generic\Navigation\StartDate.BMP
;~ startX:= x
;~ startY:= y
;~ x += 2
;~ imagesearch, x, y, %X%, %Y%, %A_ScreenWidth%, %A_ScreenHeight%, C:\Autohotkey\Tapestry\Generic\Navigation\divider.BMP
;~ Mousemove, %X%, %Y%

;~ width:= x - StartX

		;~ ocrX := startX
		;~ ocrY := startY
		;~ ocrW := width
		;~ ocrH := 15
		;~ ocrY += 20

;~ authDates:= []
;~ counter = 0
;~ Loop
;~ {
	;~ winwaitactive, Hyperspace
	;~ gosub OCR	; Get text from screenshot
	;~ if ocrText
	;~ {
		;~ counter = 0
		;~ authDates.Push(ocrText)
		;~ ocrY += 17
	;~ }
	;~ Else 
	;~ counter += 1

;~ if (counter >= 3)
	;~ break
;~ }
;~ msgbox aight









;~ imagesearch, x, y, 0, 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\Autohotkey\Tapestry\Generic\Navigation\id.BMP
;~ startX:= x
;~ startY:= y
;~ x += 2
;~ imagesearch, x, y, %X%, %Y%, %A_ScreenWidth%, %A_ScreenHeight%, C:\Autohotkey\Tapestry\Generic\Navigation\divider.BMP
;~ Mousemove, %X%, %Y%

width:= x - StartX
;~ first
		ocrX := startX+1
		ocrY := startY
		ocrW := width
		ocrH := 18
		ocrY += 20
Screenshot(ocrX, ocry, ocrW, ocrH, "C:\AutoHotkey\Tapestry\Generic\OCR\Screenshot.bmp")
msgbox wait
authNumbers:= []
counter = 0
Loop
{
	winwaitactive, Hyperspace
	gosub OCR	; Get text from screenshot
	;~ msgbox wait
	
	if ocrText
	{
		counter = 0
		authNumbers.Push(ocrText)
		ocrY += 17
	}
	Else 
	counter += 1


;~ msgbox % counter
if (counter >= 3)
	break
}
msgbox aight

for index in authnumbers
	msgbox % authDates[A_INDEX] . "    " . authNumbers[A_INDEX]

;~ Screenshot(ocrX, ocry, ocrW, ocrH, "C:\AutoHotkey\Tapestry\Generic\OCR\Screenshot.bmp")	
		;~ ocrY += 17
;~ Screenshot(ocrX, ocry, ocrW, ocrH, "C:\AutoHotkey\Tapestry\Generic\OCR\Screenshot.bmp")
		;~ ocrY += 17
;~ Screenshot(ocrX, ocry, ocrW, ocrH, "C:\AutoHotkey\Tapestry\Generic\OCR\Screenshot.bmp")

			gosub OCR	; Get text from screenshot
msgbox % ocrText

return













OCR:
numberMatrix:= [" BBBB B    BB    BB    BB    BB    BB    BB    BB    B BBBB ","  B BBB B  B  B  B  B  B  B  B"," BBBB B    B     B     B     B    B    B    B    B    BBBBBB"," BBBB B    B     B     B  BBB      B     B     BB    B BBBB ","    B    BB    BB   B B   B B  B  B  B  B BBBBBB    B     B "," BBBBB B     B    B     BBBBB B    B     B     BB    B BBBB "," BBBB B    BB     B     B BBB BB   BB    BB    BB    B BBBB ","BBBBBB    B     B    B     B    B     B    B     B     B    "," BBBB B    BB    BB    B BBBB B    BB    BB    BB    B BBBB "," BBBB B    BB    BB    BB   BB BBB B     B     BB   B  BBB  ","         B","   B     B"]
	matrixTrans:= ["0","1","2","3","4","5","6","7","8","9",".",":"]
; Number matrix / trans line up to determine OCR results from the end product string


l1 := []
l2 := []
l3 := []
l4 := []
l5 := []
l6 := []
l7 := []
l8 := []
l9 := []
l10 := []
colorchoices:= ["4278190080","4281545523","4294967295"]

number:= 
numberStorage:= []
startVar:= 
ocrText:= 
breakCheck:=  
color:=  
contCar:=  
e:=  
Element:=  
file1:=  
Height:=  
i:=  
index:=  

line:=  
lineNumber:=   
maxCheck:=  
n:=  
number:=  
 
res:=  
row:=  
startVar:=  
V:=  
Width:=  
x:=  
y:= 
tc = 1
; Stuff declared

;~ Loop	; Take a screenshot at specified coordinates - wait until screenshot has an actual image
			;~ {
				;~ Screenshot(ocrX, ocry, ocrW, ocrH, "C:\AutoHotkey\Tapestry\Generic\OCR\Screenshot.bmp")
				;~ if checkProcessed("C:\AutoHotkey\Tapestry\Generic\OCR\Screenshot.bmp")
					;~ break
				;~ msgbox doop
				
			;~ }


reGet:

	numberStorage:= []
	file1 = C:\AutoHotkey\Tapestry\Generic\OCR\Screenshot.bmp	; Source file
	If !pToken := Gdip_Startup()
	{
		MsgBox, 48, Error!, Image edit failed.
		ExitApp
	}
	
	color = %A_SPACE%
	
	pBitmapFile1 := Gdip_CreateBitmapFromFile(File1)
	Width := Gdip_GetImageWidth(pBitmapFile1), Height := Gdip_GetImageHeight(pBitmapFile1)
	processed = 0
	x=0
	y=0
	res = 1
	
	cBack:= Gdip_GetPixel(pBitmapFile1, 1, 1)
	
	textColor:= colorChoices[tc]
	loop %Height%
	{
		loop %Width%
		{
			;~ msgbox % row
			row:= row . A_SPACE . Gdip_GetPixel(pBitmapFile1, x, y)
			x++
		}

		ifinstring, row, %textColor%	; Any verticle row with black pixels gets pulled out
			color = %Color%`r`n%row%

		row = 
		x=0
		y++
	}
	
	
 
	;~ msgbox cewcwec
	;~ StringTrimleft, color, color, 3
	Stringreplace, color, color, `r`n%A_SPACE%,`r`n,all
	Stringreplace, color, color,%cBack%,%A_SPACE%,all
	Stringreplace, color, color,%textColor%,B,all	; Clean up the end product
	StringTrimleft, color, color, 2
	clipboard:= color
	;~ msgbox % color
	Loop, 100
	{
		Stringreplace, color, color, %A_SPACE%%A_SPACE%,|,all
	}
	Stringreplace, color, color, %A_SPACE%,,all
	Stringreplace, color, color, |,%A_SPACE%,all	; Clean up the end product

	Stringreplace, texttest, color, %A_SPACE%,,all
	if not texttest
		if tc < 3
	{
	Gdip_DisposeImage(pBitmapFile1)
	Gdip_DeleteGraphics(G)
	Gdip_Shutdown(pToken)
	Gdip_DisposeImage(pBitmapFile2)
	Gdip_DeleteGraphics(G)
	Gdip_Shutdown(pToken)
	tc++
	goto reget
	}

	if not color
	{
		ocrText = 
		return
	}
	n = 1
	Loop, parse, color, `r
	{
		Element:= A_LoopField
		Stringreplace, element, element, `n,,all
		Stringreplace, element, element, `r,,all
		
		Loop, parse, element
		{
			l%n%.Push(A_LoopField)	; Essentially rotates the lines stored in the array from 'up-down' to 'left-right'
		}
		
		n++
	}

	numberMatrix:= [" BBBB B    BB    BB    BB    BB    BB    BB    BB    B BBBB ","  B BBB B  B  B  B  B  B  B  B"," BBBB B    B     B     B     B    B    B    B    B    BBBBBB"," BBBB B    B     B     B  BBB      B     B     BB    B BBBB ","    B    BB    BB   B B   B B  B  B  B  B BBBBBB    B     B "," BBBBB B     B    B     BBBBB B    B     B     BB    B BBBB "," BBBB B    BB     B     B BBB BB   BB    BB    BB    B BBBB ","BBBBBB    B     B    B     B    B     B    B     B     B    "," BBBB B    BB    BB    B BBBB B    BB    BB    BB    B BBBB "," BBBB B    BB    BB    BB   BB BBB B     B     BB   B  BBB  ","         B","   B     B","   B   B  B   B   B  B   B   B  B   B   ","   B BBBB    BB    B  B      B  B      B  B      B B      B  B     B   B    B   B    B    B   BBBBBB","   B BBBB    BB    B  B      B  B      B  B   BBB  B       B B       B B       BB   B    BB    BBBB ","   B    B    B   BB   B    BB   B   B B   B   B B  B   B  B  B   B  B  B  BBBBBBB       B B       B ","   B BBBBB   B B      B  B      B B       B BBBBB  B  B    B B       B B       BB   B    BB    BBBB ","   B BBBB    BB    B  B B       B B       B B BBB  B  BB   B B  B    B B  B    BB   B    BB    BBBB ","   BBBBBBB   B    B   B     B   B    B    B    B   B    B    B    B    B   B    B    B    B    B    ","   B BBBB    BB    B  B B    B  B B    B  B  BBBB  B  B    B B  B    B B  B    BB   B    BB    BBBB ","   B BBBB    BB    B  B B    B  B B    B  B B   BB B   BBB B B       B B       BB   B   B B    BBB  "]
	matrixTrans:= ["0","1","2","3","4","5","6","7","8","9",".",":","/","/2","/3","/4","/5","/6","/7","/8","/9"]

	for index in l1
		V:= v . l1[A_INDEX] . l2[A_INDEX] . l3[A_INDEX] . l4[A_INDEX] . l5[A_INDEX] . l6[A_INDEX] . l7[A_INDEX] . l8[A_INDEX] . l9[A_INDEX] . l10[A_INDEX] . "`r`n"


	numberStorage:= {}
	breakCheck = 0
	maxCheck:= L1.MaxIndex()
clipboard:= color

contCar = 0
startVar = 1
Loop
{
	

	Loop, 
	{

		line:= l1[startVar] . l2[startVar] . l3[startVar] . l4[startVar] . l5[startVar] . l6[startVar] . l7[startVar] . l8[startVar] . l9[startVar] . l10[startVar]

		ifinstring, line, b
		{
			n:= startVar	; Find where text starts
			break
		}
		startVar++
				if (StartVar >= maxCheck)
				{
					breakCheck = 1
					break
				}
				
	}
	if breakCheck
		break

	Loop, 
	{
		line:= l1[A_INDEX + n] . l2[A_INDEX + n] . l3[A_INDEX + n] . l4[A_INDEX + n] . l5[A_INDEX + n] . l6[A_INDEX + n] . l7[A_INDEX + n] . l8[A_INDEX + n] . l9[A_INDEX + n] . l10[A_INDEX + n]
		ifnotinstring, line, b
		{
			e:= A_INDEX + n	; Find where character ends, no black pixels located vertically
			break
		}
	}
	
	line:= l1[e] . l2[e] . l3[e] . l4[e] . l5[e] . l6[e] . l7[e] . l8[e] . l9[e] . l10[e]
	
	lineNumber = 1
	Loop, 10
	{
		i = %n%				; Loop from identified character beginning to end and assign out the pixels into a matrix
		Loop
		{
			if (i = e)
				break
			number:= number . l%lineNUmber%[i]
			i++
		}
		lineNUmber ++
	}


;~ 1 = "  B BBB B  B  B  B  B  B  B  B"
;~ 2 = " BBBB B    B     B     B     B    B    B    B    B    BBBBBB"
;~ 3 = " BBBB B    B     B     B  BBB      B     B     BB    B BBBB "	; The end results look like this, with translation
;~ 4="    B    BB    BB   B B   B B  B  B  B  B BBBBBB    B     B "
;~ 5 = " BBBBB B     B    B     BBBBB B    B     B     BB    B BBBB "
;~ 6 = " BBBB B    BB     B     B BBB BB   BB    BB    BB    B BBBB "
;~ 7="BBBBBB    B     B    B     B    B     B    B     B     B    "
;~ 9=
;~ 8 = " BBBB B    BB    BB    B BBBB B    BB    BB    BB    B BBBB "
;~ . = "         B"


for index in numberMatrix
	if (number = numberMatrix[A_INDEX])
		numberStorage.Push(MatrixTrans[A_INDEX])	; Identify character from matrix

;~ msgbox %transl% %number%   

	number:= ; dump
	startVar:= e	; Start new search from the previous line's end
}
;~ for index in numberStorage
;~ msgbox % numberStorage[A_INDEX]
for index in numberStorage
	ocrText:= ocrText . numberStorage[A_INDEX]	; Assign out discovered characters into a new variable
	Gdip_DisposeImage(pBitmapFile1)
	Gdip_DeleteGraphics(G)
	Gdip_Shutdown(pToken)
	Gdip_DisposeImage(pBitmapFile2)
	Gdip_DeleteGraphics(G)
	Gdip_Shutdown(pToken)
msgbox % ocrText
	Sleep, 0
	return
	
	














return

;~ 408, 545

; Shortcuts - Function (AF01)    Graphics Libraries (AL01)   Graphic Recolor Sub (AR01)       Installs (AI01)      Declarations (AD01)
;Alt+0160 is nonbreaking space



Global Version := "Version3.01"	; Please do not change with wild disregard

;System installs and checks-----
	
{
installs()
}


 ; NUID entry and Change Log
ReNUID:

	
	Fileread, Var, C:\AutoHotkey\Tapestry\Program Data\Settings.txt	; Check for NUID that's been saved
		ifnotinstring, var, NUID
			Filedelete, C:\AutoHotkey\Tapestry\Program Data\Settings.txt
		ifnotexist, C:\AutoHotkey\Tapestry\Program Data\Settings.txt
		{
			Inputbox, NUID, Tapestry Toolset, Please enter your NUID`, with the first letter capitalized. You will only need to do this once per update.
					If (NUID < 0)
						Goto ReNUID
			Filedelete, C:\AutoHotkey\Tapestry\Program Data\Settings.txt
			Fileappend, NUID:%NUID%, C:\AutoHotkey\Tapestry\Program Data\Settings.txt
		}	; the changelog is entered above. Since the NUID file is deleted with each update and needs to be reentered, this ensures the changelog displays only once. Maybe add a button to display again in case it got skipped?


	Fileread, Var, C:\AutoHotkey\Tapestry\Program Data\Settings.txt	; Get the NUID for later stuff
		Stringreplace, var, var, NUID`:,,all
	User:= VAR
	


;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v1^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ----------------------MAIN GUI------------------MAIN GUI----------------------MAIN GUI------------------MAIN GUI-------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ----------------------MAIN GUI------------------MAIN GUI----------------------MAIN GUI------------------MAIN GUI-------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
Global genFor:= 
Global noGen:= 

devskip:	; Sub skips all the installs and etc, just run a goto from top. Faster testing
{ ; Main Gui 
createGui() {
	global claimParsed:= "no"
	gosub declarations
	
	Gui 3: Add, Tab3, x5 y5 w630 h400  AltSubmit,  WS/CMS ;|On Startup Custom
		Gui 3: Tab, WS/CMS	; CMS / WebStrat tab
			Gui 3: +alwaysontop
			Gui 3: Add, Button, X+90 Y+45 -theme W180 H30 gGoPercent, PercentBilled
			Gui 3: Add, Button, -theme W180 H35 gGoAutoMedi, WebStrat/RBRVS (Paper Form)
			Gui 3: Add, Button, -theme W180 H30 gparseClaim2, WebStrat/RBRVS (ANSI Values)
			Gui 3: Add, Button,-theme W180 H30 gASCCLaimPricing, ASC Manual Pricing
			Gui 3: Add, Button, -theme w180 h30 gcdidSearch, CDID Lookup
			Gui 3: Add, Button, -theme w180 h30 gAnesthesiaPricer, Anesthesia Calculator
			Gui 3: Add, Button, -theme W180 H30 gGo5, Close
			Gui 3: Add, Button,-theme W180 H30 gGo4, Reset
			Gui 3: Add, Picture, x-10 y-20 +Background W390 H450 +0x4000000, C:\Autohotkey\Tapestry\Program Data\MetalTexture.jpg
					
	Gui 3: Show, w384 h390 , Tapestry Toolsets

return

}
gosub Declarations
createGUI()
return


}



; Code below is not completed / experimental
{

;~ acceptStartup:
;~ Gui 3: Submit
;~ Gui 3: Destroy

;~ FileDelete, C:\Autohotkey\Tapestry\Program Data\startup.txt
;~ Loop
;~ {
	;~ ifnotexist, C:\Autohotkey\Tapestry\Program Data\startup.txt
		;~ break
;~ }

;~ FileAppend, %addFor%, C:\Autohotkey\Tapestry\Program Data\startup.txt
;~ Msgbox Settings accepted.
;~ createGUI()
;~ return

;~ addSite:

;~ Gui 3: Submit
;~ Gui 3: Destroy
;~ Gui, Add, text, , Please enter the URL to add below.
;~ Gui, Add, Edit, vWebEdit w200
;~ Gui, Add, Button, gAcceptWebSite, Accept

;~ Gui, Add, Button, X+20 gStandardCancel, Cancel
;~ Gui, Show
;~ return


;~ acceptWebSite:
;~ Gui, Submit
;~ Gui, Destroy
	;~ StandardMSProg = Website:%webEdit%
;~ Gosub msStandardAdd
;~ return




;~ ClearAllStartup:
;~ Gui 3: Submit
;~ Gui 3: Destroy
;~ addFor = 
;~ startLaunch = 
;~ gosub standardCancel

;~ return

;~ fileFolders:
;~ Gui 3: Submit
;~ Gui 3: Destroy
;~ Gui Files: +AlwaysonTop
;~ Gui FileS: Add, Button, gFileSelFolder, Select Folder
;~ Gui FileS: Add, Button, gFileSelFile, Select File
;~ Gui FIleS: Add, Button, gstandardCancel, Cancel
;~ Gui FIles: Show
;~ return

;~ cancelFile:
;~ Return
;~ FileSelFolder:
;~ Gui Files: Destroy
;~ FileSelectFolder, folder
;~ if folder
;~ {
;~ StandardMSProg = Folder: %folder%
;~ goto msStandardAdd
;~ return
;~ }
;~ else
	;~ Goto skypecancel
;~ return

;~ fileSelFile:
;~ Gui Files: Destroy
;~ FileSelectFile, file, , C:\Users\%username%\Desktop\
;~ if file
;~ {
;~ StandardMSProg = File: %file%
;~ goto msStandardAdd
;~ return
;~ }
;~ else
	;~ Goto skypecancel
;~ return


;~ removeProgram:
;~ Gui 3: Submit
;~ Gui 3: Destroy

;~ addFor = |%addFor%|

;~ Stringreplace, addFor, addFor, |%startLaunch%|,|,all
;~ Stringreplace, addFor, addFor, ||,|,all
;~ Stringtrimleft, addFor, addFor, 1
;~ gosub standardCancel
;~ return

;~ standardMS:
;~ Gui 3: Submit
;~ Gui 3: Destroy
;~ Gui 4: Add, Button, gOutlook, Outlook
;~ Gui 4: Add, Button, gExcel, Excel
;~ Gui 4: Add, Button, gOneNote, OneNote
;~ Gui 4: Add, Button, gWord, Word
;~ Gui 4: Add, Button, gstandardCancel, Cancel
;~ Gui 4: Show,w100
;~ return


;~ outlook:
;~ StandardMSProg = Microsoft Outlook
;~ goto msStandardAdd
;~ return
;~ excel:
;~ MsgBox, 4, , This will open a blank Excel sheet on startup.`rIf you want to open a specific Excel Sheet, press NO and select Browse.
;~ IfMsgBox No
;~ {
	;~ goto StandardCancel
	;~ return
;~ }
;~ StandardMSProg = Microsoft Excel
;~ goto msStandardAdd
;~ return
;~ oneNote:
;~ StandardMSProg = Microsoft OneNote
;~ goto msStandardAdd
;~ return
;~ word:
;~ MsgBox, 4, , This will open a blank Word Document on startup.`rIf you want to open a specific Word Document, press NO and select Browse.
;~ IfMsgBox No
;~ {
	;~ goto StandardCancel
	;~ return
;~ }
;~ StandardMSProg = Microsoft Word
;~ goto msStandardAdd
;~ return

;~ Skype:
;~ Gui 4: Destroy
;~ Gui 3: Submit
;~ Gui 3: Destroy
;~ Gui Skype: Add, Text,, Enter an email address below. `rOn Startup (and once Skype has opened)`, a blank message`rwill be opened to the specified contact.
;~ Gui Skype: Add, Edit, w400 vSkypeContact,
;~ Gui Skype: Add, Button, gSkypeOkay, Okay
;~ Gui Skype: Add, Button, x+30 gSkypeCancel, Cancel
;~ Gui Skype: Show


;~ return
;~ skypeOkay:
;~ MsgBox, 4, , To verify contact eligiblity, ***all Skype conversations will be closed***`, and will *not* be recoverable.`rIf any open conversations need to be saved, click No to cancel`r`r`rClick Yes to close all conversations and continue.
;~ IfMsgBox No
;~ {
	;~ Gui Skype: Destroy
	;~ goto StandardCancel
	;~ return
;~ }
;~ Loop
;~ {
	;~ ifwinnotexist, ahk_class LyncConversationWindowClass
		;~ break
	;~ Winclose, ahk_class LyncConversationWindowClass
;~ }

;~ Success = 
;~ Gui Skype: Submit, nohide
;~ ifinstring, SkypeContact, %userName%
	;~ Success = NO
;~ ifnotinstring, skypeContact, @
	;~ skypeContact = %skypeContact%@accenture.com
	

;~ if (Success = "")
	;~ Run, lync.exe im:"<sip:%skypeContact%>"


;~ if Success = ""
	
;~ ifwinexist, ahk_class LyncConversationWindowClass
;~ {
	;~ winactivate, ahk_class LyncConversationWindowClass
;~ winwaitactive, ahk_class LyncConversationWindowClass
;~ }
;~ Loop
;~ {
	;~ ifwinexist, ahk_class NUIDialog
	;~ {
		;~ ControlSend, , {Escape}, ahk_class NUIDialog
		;~ Success = NO
		;~ break
	;~ }
	;~ ifwinexist, ahk_class LyncConversationWindowClass
	;~ {
		;~ Winclose, ahk_class LyncConversationWindowClass
		;~ Success = YES
		;~ break
	;~ }		
;~ }

;~ if success = NO
;~ {
	;~ Msgbox %SkypeContact% could not be verified as a valid Skype Contact.
	;~ return
;~ }
;~ else
	;~ Msgbox %SkypeContact% has been successfully verified.
;~ Gui 3: Submit
;~ Gui 3: Destroy
;~ Gui Skype: Submit
;~ Gui Skype: Destroy
;~ StandardMSProg = Ping To: %skypeCOntact%
;~ goto msStandardAdd


;~ return
;~ SkypeCancel:
;~ Gui 3: Submit
;~ Gui 3: Destroy
;~ Gui Skype: Submit
;~ Gui Skype: Destroy
;~ Stringreplace, addFor, addFor, ||,|,all
;~ Stringleft, addforTest, addFor, 1
;~ if (addForTest = "|")
	;~ StringTrimleft, addFor, addFor, 1
;~ createGui()
;~ loop
	;~ ifwinexist, Tapestry Toolsets
		;~ break
	;~ ControlSend, , {up}{up}{right},Tapestry Toolsets
	;~ return

;~ return

;~ standardCancel:
;~ Gui 4: Destroy
;~ Gui, Destroy
;~ Stringreplace, addFor, addFor, ||,|,all
;~ Stringleft, addforTest, addFor, 1
;~ if (addForTest = "|")
	;~ StringTrimleft, addFor, addFor, 1
;~ createGui()
;~ Loop
	;~ ifwinexist, Tapestry Toolsets
		;~ break
	;~ ControlSend, , {up}{up}{right},Tapestry Toolsets
	;~ return

;~ msStandardAdd:
	;~ addFor = %addFor%|%StandardMSProg%|
	;~ Stringreplace, addFor, addFor, ||,|,all
;~ Stringleft, addforTest, addFor, 1
;~ if (addForTest = "|")
	;~ StringTrimleft, addFor, addFor, 1
	;~ Gui 4: Destroy
	;~ GuiControl,,startLaunch,%addFor%
	;~ createGui()
	;~ loop
	;~ ifwinexist, Tapestry Toolsets
		;~ break
	;~ ControlSend, , {up}{up}{right},Tapestry Toolsets
	;~ return


;~ swap:
;~ swapBack:
;~ modify:
;~ return


;~ ;CRM SUBS
;~ { ;----------------------;Experimental----------------------------
;~ CRM:
;~ Gosub Declarations
	;~ Gui 3: Submit
	;~ Gui 3: Destroy
	;~ Gui 3: Destroy
		;~ Gui CRM: Destroy
		;~ Gui CRM: +Alwaysontop
		;~ Gui CRM: Add, Button, -Theme gOCI w100, OCI
		;~ Gui CRM: Add, Button, W100 -Theme gcloseCRM y+20, Back to Main
		;~ Gui CRM: Add, Picture, x-10 y-20 +Background W390 H380 +0x4000000, C:\Autohotkey\Tapestry\Program Data\MetalTexture.jpg
		;~ Gui CRM: Show, H300 W250
		;~ return

	;~ CloseCRM:
	;~ Gui CRM: Destroy
	;~ gosub Declarations
	;~ createGUI()
	;~ return


;~ genGUIDisp:
	;~ Gui 1:+alwaysontop
		;~ if (claimTXT <> "Claim Number")
		;~ Gui 1:Add, EDIT , w150 vClaimNumber, %claimTXT%
		;~ else
		;~ {
		;~ Gui 1:Add, EDIT , w150 vClaimNumber hwndEdit2
			;~ EM_SETCUEBANNER(Edit2, claimtxt)
		;~ }
		
		;~ if (dispTXT <> "Dispute Amount (if applicable)")
		;~ Gui 1:Add, EDIT , w150 vDisputeAmount, %dispTXT%
		;~ Else
		;~ {
		;~ Gui 1:Add, EDIT , w150 vDisputeAmount hwndEdit3
			;~ EM_SETCUEBANNER(Edit3, dispTxt)
		;~ }
		;~ Gui 1:Add, text, x10 y75, Received Date
		;~ if (recDate > 0)
			;~ Gui 1:add, dateTime, vRecDate choose%recDate%,
		;~ else
			;~ Gui 1:add, dateTime, vRecDate
				;~ Gui 1:Add, text, ,
				;~ Gui 1:Add, text, ,
				;~ Gui 1:Add, text,  X180 Y5,Type of Dispute
		;~ if (disputeList <> "")
			;~ Gui 1:Add, DropDownList, x180 y20 vDisputeList choose1, Underpayment|More to be Added
		;~ else
		;~ Gui 1:Add, DropDownList, x180 y20 vDisputeList, Underpayment|More to be Added
		;~ Gui 1: Add, checkbox, vManProv, Check Provider Manually?
		;~ if (NoteList = "")
			;~ Gui 1:add, Button, x10 y120 vaddChange gAddNotes, Add Notes
		;~ Else
			;~ Gui 1:add, Button, x10 y120 vaddChange gAddNotes, Change Notes
		;~ Gui 1:add, Text, x10 y150 w300 vNotes, %noteList%
		;~ Gui 1:add, Button, w100 gGO, Accept and Go
		;~ Gui 1:Show
		;~ GuiControl, Text, Notes, %A_SPACE%
		;~ return
	;~ AddNotes: 
	;~ Gui 1: Submit
	;~ Gui 2: Font, s12

	;~ Fileread, disputeNotes, C:\Autohotkey\Tapestry\Program Data\disputeNotes.txt
	;~ Gui 2: Add, listBox , vNoteList W900 H375, %disputeNotes%

	;~ Gui 2: Add, Button, gAcceptNotes, Accept or Add Notes
	;~ Gui 2: Add, Button, gCancelNotes, Cancel
	;~ Gui 2: Add, Button, gDeleteNotes X200 Y382, Delete Notes
	;~ Gui 2: Show
	;~ return	
	;~ acceptNotes:
	;~ Gui 2: Submit
	;~ Gui 2: Destroy
	
	;~ ifinstring, noteList, Add Manual
	;~ {
		;~ Gui 3: Add, EDIT , w400 vnotetoAdd hwndEdit4
			;~ EM_SETCUEBANNER(Edit4, "Type New Note Here"),  
			;~ Gui 3: Add, Button, gAcceptNewNote, Accept Note
			;~ Gui 3: Add, Button, gcancelNew, Cancel New Note
			
		;~ Gui 3: Show
		;~ return
	;~ }
	
	;~ Gui 1: Destroy
	;~ goto GenGUIDisp
	
;~ return	
	;~ cancelNotes:
	;~ Gui 1: Submit
;~ Gui 1: Destroy
;~ Gui 2: Destroy
;~ noteList = 
;~ Gosub genGUIDisp

;~ return	


;~ acceptNewNote:

;~ Gui 3: Submit
;~ Gui 3: Destroy
;~ ifnotinstring, notetoAdd, Add Manual Note
;~ {
;~ Stringreplace, disputeNotes, disputeNotes, |Add Manual Note,,all
;~ disputeNotes = %disputeNotes%`|%noteToAdd%`|Add Manual Note
;~ Loop, 50
;~ Stringreplace, disputeNotes, disputeNotes, `|`|,`|,all

;~ FileDelete, C:\Autohotkey\Tapestry\Program Data\disputeNotes.txt
;~ Fileappend, %disputeNotes%, C:\Autohotkey\Tapestry\Program Data\disputeNotes.txt
;~ Gui 2: Destroy
;~ }
;~ Else 
;~ Msgbox ERROR! Invalid entry.
;~ Gosub addNotes
;~ return
		;~ DeleteNotes:
		;~ Gui 2: Submit
		;~ Gui 2: Destroy
;~ ifnotinstring, noteList, Add Manual Note
;~ {
	;~ Stringreplace, disputeNotes, disputeNotes, |Add Manual Note,,all
	;~ disputeNotes = %disputeNotes%|
	
	;~ Stringreplace, disputeNotes, disputeNotes, |%noteList%|,,all
	;~ Loop, 50
	;~ Stringreplace, disputeNotes, disputeNotes, `|`|,`|,all
	;~ disputeNotes = %disputeNotes%|Add Manual Note

	;~ FileDelete, C:\Autohotkey\Tapestry\Program Data\disputeNotes.txt
	;~ Fileappend, %disputeNotes%, C:\Autohotkey\Tapestry\Program Data\disputeNotes.txt
	;~ Gui 2: Destroy
;~ }
;~ Gosub addNotes
		
		;~ Return

;~ CancelNew:
;~ Gui 1: Submit
;~ Gui 1: Destroy
;~ Gui 2: Destroy
;~ Gui 3: Destroy
;~ Gosub addNotes

;~ Return









;~ go:

;~ Gui 1: Submit
;~ Gui 1: Destroy




;~ FormatTime, todayDate, %A_NOW%, MM/dd/yyyy
;~ FormatTime, recDate, %recDate%, MM/dd/yyyy




;~ Global otherCovName:= 
;~ OCI:
;~ GUI CRM: Destroy

;~ Gui OCI: Add, Text, , Sending CRM To:
;~ Gui OCI: add, Radio, vOCICommercial, OCI Commercial
;~ Gui OCI: add, Radio, vOCIMedicare gAddMedicareGUI y+10, OCI Medicare
;~ Gui OCI: add, Radio, vOCIOther Y+10, OCI Other
;~ Gui OCI: add, Text, y5 x+60, About Other Coverage Name: 
;~ Gui OCI: Add, Edit, y+30 votherCovName, %otherCovName%
;~ Gui OCI: Add, Text, x+65 Y5, Because:
;~ Gui OCI: Add, Radio, vOtherCovNotListed Y+10, Other Coverage is not Listed in the AFO
;~ Gui OCI: Add, Radio, vKPIsPrime Y+10, KP is listed as the Primary coverage in the AFO
;~ Gui OCI: Add, Button, x5 Y120 gGoOCI, Accept CRM
;~ Gui OCI: Add, Button, x5 y+20 gCancelOCI, Cancel CRM



;~ Gui OCI: Show
;~ return


;~ AddMedicareGUI: 
;~ Gui OCI: Submit, noHide
;~ otherCovName = Medicare

;~ GuiControl, TExt, Edit1, Medicare

;~ return
;~ cancelOCI:
;~ Gui OCI: destroy
;~ Gosub Declarations
;~ CreateGUI()
;~ return


;~ GoOCI:
;~ Gui OCI:Submit
;~ if (OCICommercial = 1)
;~ {
	;~ OCIType = Commercial
	;~ EOType = EOB
;~ }
;~ if (OCIMedicare = 1)
;~ {
	;~ OCIType = Medicare
	;~ EOType = EOMB
;~ }
;~ if (OCIOther = 1)
	;~ OCIType = Other

;~ If (OtherCovNotListed = 1)
	;~ OCIReason = other coverage is not listed in the AFO.
	;~ if (KPIsPrime = 1)
	;~ OCIReason = KP is listed as primary in the AFO.
;~ If (Other = 1)
	;~ InputBox, OCIReason, OCI Reason, Please enter a short description of why you are sending the CRM.



;~ OCICommercial:
;~ Gui CRM: Destroy
;~ SubTopic = Commercial

	;~ Winactivate, Hyperspace
			
	;~ getStyle(Style)
		;~ If (errorChecking = "NO") {
			;~ gosub declarations
			;~ msgbox an Error has occured.
			;~ createGUI()
			;~ return
				;~ }
		;~ t:= Style		; Performs an image search to determine what the style is
		;~ theme:= Style	; Style determines the directory for future searches	
	



;~ navMain("Crm",t)




	;~ reColor:= ["newCRM", "00FF36", 112, 144]
	;~ gosub ReColor

	;~ GenSearch(0,0,asw,ash,"newcrmEND")

	;~ Mousemove,%X%, %Y%
	;~ Click, left

		;~ Loop
		;~ {
			;~ GenSearch(0,0,asw,ash,"SourceType")
				;~ if errorlevel = 0
				;~ {
					;~ x1:= x
					;~ y1:= y
					;~ Sleep, 100
					;~ GenSearch(0,0,asw,ash,"SourceType")
					;~ if (x = X1 AND y = y1)
						;~ break
				;~ }
			;~ }
			








		;~ Send, Kai{TAB}CCA
		
		;~ GenSearch(0,0,asw,ash,"Topic")
			;~ x += 10
			;~ Y += 25
			
			;~ Mousemove, %X%, %Y%
			;~ Sleep, 100
			;~ Click, left
		;~ GenSearch(0,0,asw,ash,"Topic")
			;~ x += 10
			;~ Y += 25
			
			;~ Mousemove, %X%, %Y%
			;~ Sleep, 100
			;~ Click, left
			;~ Click, Left
	
		;~ GenSearch(0,0,asw,ash,"TopicSel")
		;~ Send, Other Cov{TAB}
		;~ GenSearch(0,0,asw,ash,"SubTopic")
		;~ Send, %OCIType%{TAB}
		;~ Sleep, 300
		;~ Send, Sending to %ociType% OCI - %otherCovName% %EoType% attached`, %OCIReason%
		;~ Mousemove, 142, 213
		;~ Click, Left
		
			;~ Loop
			;~ {
				;~ ImageSearch, X, Y,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, *TransWhite C:\Autohotkey\Tapestry\Generic\Other.PNG
				;~ if ErrorLevel = 0
					;~ break
			;~ }
				;~ Mousemove, %x%,%y%
				;~ Click, Left

				;~ Loop
			;~ {
				;~ ImageSearch, X, Y,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, *TransWhite C:\Autohotkey\Tapestry\Generic\outgoing.PNG
				;~ if ErrorLevel = 0
				;~ {
					;~ ImageSearch, Xx, Yy,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, *TransWhite C:\Autohotkey\Tapestry\Generic\outgoing.PNG
					;~ if ErrorLevel = 0
						;~ (if xx = x AND yy = Y)
						;~ break
					;~ }
			;~ }			
				;~ Mousemove, %X%, %Y%
				;~ Click, Left
				;~ Sleep, 500
			;~ Send, {Tab}In Basket{Tab}
			;~ Loop
			;~ {
				;~ ImageSearch, X, Y,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, *TransWhite C:\Autohotkey\Tapestry\Generic\Source.PNG
				;~ if ErrorLevel = 0
					;~ break
			;~ }		
;~ Mousemove, %X%, %Y%
;~ Click, left
						
;~ return



		;~ Loop
	;~ {
				;~ ImageSearch, X, Y,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, %deri%smallAlertSelected.BMP
				;~ if ErrorLevel = 0
					;~ break
	;~ }
	
	;~ Send, Provider Dispute{TAB}Underpayment{TAB}
	
			;~ Loop
	;~ {
				;~ ImageSearch, X, Y,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, %deri%comTick.BMP
				;~ if ErrorLevel = 0
					;~ break
	;~ }
;~ Send, %NoteList%
;~ Sleep, 400

;~ Mousemove, 140, 356
;~ Click, Left
			;~ Loop
	;~ {
				;~ ImageSearch, X, Y,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, %deri%provDisp.BMP
				;~ if ErrorLevel = 0
					;~ break
	;~ }
	;~ Sleep, 300
;~ Mousemove, %X%, %Y%
;~ Click, Left



;~ Loop
	;~ {
				;~ ImageSearch, X, Y,0,0, %A_ScreenWidth%, %A_ScreenHeight%, %deri%dispAm.BMP
				;~ if errorlevel = 0
					;~ break
				
				
	;~ }

	;~ Mousemove, 498, 360
	;~ Click, Left
	
			;~ Loop
	;~ {
				;~ ImageSearch, X, Y,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, %deri%formSelected.BMP
				;~ if ErrorLevel = 0
					;~ break
	;~ }
	;~ If (disputeAmount > 0)
		;~ Send, %disputeAmount%
	
;~ Sleep, 300

;~ Send, {TAB 2}
;~ Sleep, 300

;~ Send, %todayDate%{Tab 2}
;~ Sleep, 300
;~ Send, %recDate%


;~ Mousemove, 143, 326
;~ Click, Left

;~ Sleep, 600

;~ Mousemove, 360, 287
;~ Click, Left

;~ Winwaitactive, Letter Editor
;~ Loop,
;~ {
;~ ImageSearch, X, Y,0,0, %A_ScreenWidth%, %A_ScreenHeight%, %deri%Ente.BMP
				;~ if errorlevel = 0
				;~ break
			;~ }
;~ Send, {F2}
;~ Sleep, 300
;~ Send, %recDate%
;~ Sleep, 300
;~ Send, {Alt Down}A{Alt Up}
;~ Winwaitactive, Hyperspace

;~ Sleep, 300
;~ Mousemove, 142, 216
;~ Click, Left
			;~ Loop
	;~ {
				;~ ImageSearch, X, Y,0, 0, %A_ScreenWidth%, %A_ScreenHeight%, %deri%incMail.BMP
				;~ if ErrorLevel = 0
					;~ break
	;~ }
;~ Mousemove, %X%, %Y%
;~ Click, Left


;~ Gosub Declarations
;~ createGui()
;~ return

;~ }

}

; End experimental code






AnesthesiaPricer:

		Gui Anesthesia: +Alwaysontop
		Gui Anesthesia:Add, EDIT , w100 VxDollars hwndEditXD
			EM_SETCUEBANNER(EditXD, "$0.00 Per Unit")
		Gui Anesthesia:Add, Button, gAnesthesiaCalc, Price

Gui Anesthesia: Show
return
AnesthesiaCalc:

gosub declarations
	Gui 3: Submit
	Gui 3: Destroy
	gosub declarations
	Winactivate, Hyperspace
	
	getStyle(Style)	; Return the graphic theme being used
		If (errorChecking = "NO") {
			gosub declarations
			msgbox an Error has occured.
			createGUI()
			return
				}
		t:= Style		
		theme:= Style		

Gui Anesthesia: Submit

navMain("dx",t)


	reColor:= ["quantity", "00FF36", 353, 119]
	gosub ReColor

	GenSearch(0,0,asw,ash,"quantityEND")
	Loop
	{
		imagesearch, x, y, %x%, %y%, %A_ScreenWidth%, %A_ScreenHeight%,C:\Autohotkey\Tapestry\Generic\Border.bmp
		if errorlevel = 0
			break
	}
	

		ocrX := X+2
		ocrY := Y+2
		ocrW = 45
		ocrH = 20
		Loop
		{
			gosub OCR	; Get text from screenshot
			Stringreplace, OCRText, OCRText, %A_SPACE%,,all
			Stringreplace, OCRText, OCRText, `r,,all
			Stringreplace, OCRText, OCRText, `n,,all
		if ocrText
			break
		}
		Stringreplace, ocrText, ocrText, :,,all	; Wait to continue until the line number matches what line is being processed
pricing:= Round(ocrText * xDollars,2)

clipboard:= pricing
Msgbox $%pricing% calculated. Amount has been copied to clipboard.
		createGUI()

return




			return

;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; --------------------ASC SUBS--------------------ASC SUBS-------------------ASC SUBS-----------------ASC SUBS-----------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; --------------------ASC SUBS--------------------ASC SUBS-------------------ASC SUBS-----------------ASC SUBS-----------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v


ascClaimPricing:

if (claimParsed <> "YES")
{

	gosub declarations
	Gui 3: Submit
	Gui 3: Destroy
	
	
	Winactivate, Hyperspace
	
	getStyle(Style)	; Return the graphic theme being used
		If (errorChecking = "NO") {
			gosub declarations
			msgbox an Error has occured.
			createGUI()
			return
				}
		t:= Style		
		theme:= Style		

	form(t,y)	; Parse the claim for the ASC Codes
		If (errorChecking = "NO") {
			gosub declarations
			msgbox An error has occured.
			createGUI()
			return
		}
		
}


{
	dateFormatWS(fromDate)	; Change date into workable text
	dos:= outputDate
	Fileread, masterVar, C:\Autohotkey\Tapestry\Program Data\ascRatesMaster.txt	; List of all the rates

for index in iHCPCS
{
	proc:= StrReplace(ihcpcs[A_INDEX],A_SPACE)
	if proc
	ifinstring, masterVar, `;%proc%		; Look for procedure code in the master rates file
	{
		number = 
		StringSplit, d, dos,`/
		if (strLen(d1) = 1)
			d1 = 0%d1%
		if (strLen(d2) = 1)
			d2 = 0%d2%
		if (strLen(d3) = 2)
			d3 = 20%d2%
		dosConverter = %d3%%d1%%d2%017			; format date of service

	for index in ascDates
	{
		dateCheck:= dosConverter
		dateCheck -= (ascDates[A_INDEX]), days	; Find the range of dates listedd
		if (dateCheck <= 0) 
		{
			if A_INDEX > 1
			{
				if (DateCheck < 0)
				{
					number:= (A_INDEX - 1)
					dateRange:= (ascDates[(A_INDEX - 1)])
				}
				Else
				{
					number:= (A_INDEX)
					dateRange:= (ascDates[(A_INDEX)])				
				}
			}
			Else, number = 1
			break
		}
	}


	if not number
		number = 8
	iterations:= number
	
mList:= ["January","February","March","April","May","June","July","August","September","October","November","December"]	; easier

		;~ := ascDates[(number)]
	StringLeft, veriYear, ascVeri,4
	StringTrimleft, veriMonth, ascVeri, 4	; Convert to workable date
	Stringleft, veriMonth, veriMonth, 2
		
			
	veriMonth:= mList[veriMonth]	; meh


	var:= masterVar
	var:= (subStr(var,((inStr(var,"`;" . proc))+1)))
	var:= (subStr(var,((instr(var,"`:")+1))))	; Looks for the ASC Code in the list and pulls the price out
	var:= (subStr(var,1,(instr(Var,"`;"))-1))
	Loop, parse, var, `,
		if (A_INDEX = Iterations)
		{
			ascHCPCS.Push(proc)	; Add to running list
			ascPrice.Push(A_LoopFIeld)
			break
		}
}
}


}

	StringRight, year, dos, 4
	
	if year = 2015	; same data
	year = 2016

	Fileread, Var, C:\AutoHotkey\Tapestry\Program Data\asc%year%.txt	; Look for specific rates
		if instr(var,zipCode)
		wage:= (subStr((subStr((subStr(var,(instr(var,zipCode)))),(instr((subStr(var,(instr(var,zipCode)))),":")+1))),1,instr((subStr((subStr(var,(instr(var,zipCode)))),(instr((subStr(var,(instr(var,zipCode)))),":")+1))),"`,")-1))
		else, wage = error	; Pull out wage index




pricePoint:= [1,1,1]	; Percentage. Changable.



reASC:
	Gui, Add, text, y+5, Calculations are - ( (1/2 ASC Rate) * wage index of %wage% ) + (1/2 ASC Rate)`r`rRates calculated using %year% wage index for ZIP Code %zipCode%`r`rBased on DOS of %outPutDate%`, ASC Rates for %veriMonth% %veriYear% were used.	; For the users' sake
	Gui, Add, text, y+20, Double click a line to copy the calculated ASC Price.
	
	Gui, Add, ListView, vLV1  w400 gCopyASCList, HCPCS Code|ASC Rate Found|Wage Index|Manual ASC Rate Calculated

	for index in ascPrice
	{
		if (A_INDEX <= 3)
			multi:= pricePoint[A_INDEX]
		else
		multi:= pricePoint[3]
		proc:= ascHCPCS[A_INDEX]
		price:= ascPrice[A_INDEX]
		
		calculation:= Round(((price * .5) * Wage + (price * .5)* multi),2) 	; Do the math
		
		Gui, ListView, LV1
		LV_Add("", proc,price,wage,"$"Calculation)	; List of the code with its price
	}	
Gui, Add, text, , Use the buttons below to recalculate the ASC Rate.

Gui, add, button,x5 g111, 100/100/100 Rates
Gui, add, button,x+20 g10505, 100/50/50 Rates	; Common calculation rates
Gui, add, button,x+20 g105025, 100/50/25 Rates
Gui, add, button,x5 y+30 gexitASC, Close
Gui, Show

return
exitASC:
Gui, Destroy
createGUI()
return

copyASCList:
if A_GuiEvent = DoubleClick
{
    LV_GetText(RowText, A_EventInfo,4)  ; Get the text from the row's first field.
	ifinstring, rowText, $
	{
	Stringreplace, rowText, rowText, $,,all
	Clipboard:= rowText
	clipwait
	Loop, 100	; Assign to clipboard
	{
		MouseGetPos, x, y
		x += 20
		y += 10
		ToolTip, %rowText% Copied to clipboard!,%x%,%Y%		; The tooltip appears under the mouse
		Sleep, 1
	}

	Tooltip, , 
}
}
return
111:
pricePoint:= [1,1,1]
Gui, Destroy
gosub reASC
return
10505:
pricePoint:= [1,.5,.5]	; Changes percentage codes will be priced at
Gui, Destroy
gosub reASC
return
105025:
pricePoint:= [1,.5,.25]
Gui, Destroy
gosub reASC
return

{ ;----------------------;ASC Grouping----------------------------
		GoGroup:
		{ ;----------------------;Performs a parse/Stringsplit of ASC group data. returns a value to GUI if present----------------------------
			
			Gui 3: Submit, nohide
			
			If (hcpcsASC1 > 0)
				globASC.Push(hcpcsASC1)
			If (hcpcsASC2 > 0)
				globASC.Push(hcpcsASC2)
			If (hcpcsASC3 > 0)
				globASC.Push(hcpcsASC3)
			
				for element, index in globASC
				{
					hcpcsASC:= globASC[A_INDEX]
					Fileread, group, C:\AutoHotkey\Tapestry\Program Data\ascGroups.txt	; File location
							ifnotinString, group, %hcpcsASC%
								{
									Gui 3: Show
									Winminimize, Tapestry Toolset
									Msgbox Code "%hcpcsASC%" could not be found.			; Error handling
									Winrestore, Tapestry Toolset
									return
								}
							if (hcpcsASC1 < 0 AND hcpcsASC2 < 0 AND hcpcsASC3 < 0)
								{
									Gui 3: Show
									Winminimize, Tapestry Toolset
									Msgbox Please enter a valid code.			; Error handling
									Winrestore, Tapestry Toolset
									return
								}
					Loop, Parse, group, `,
					{
						xAsc:= A_LoopField
						StringSplit, id, xAsc, `:		; Separate entries by comma, and pairs by hyphen
							if (id1 = HcpCSASC)
								Break
					}
						guiControl, text, HCPCSASCp%A_INDEX%, %hcpcsASC%: Group %id2%				; set the GUI to the group found
						Guicontrol, text, Calcs, ASC Group for %id1% is shown below.
					Gui 3: Show
				}
			return
		}	


						return

}
;----------------------;END ASC SUBS----------------------------
return


ClaimScan:
{ ;Claim scan has been largely made impossible due to system updates

gosub declarations
	Gui 3: Submit
	Gui 3: Destroy
			
	Winactivate, Hyperspace
			
	getStyle(Style)
		If (errorChecking = "NO") {
			gosub declarations
			msgbox an Error has occured.
			createGUI()
			return
				}
		t:= Style		; Performs an image search to determine what the style is
		theme:= Style	; Style determines the directory for future searches	
			
		
	gosub claimChecks		
		
		
navMain("crm",t)



Loop, 2
{
	reColor:= ["crm", "06FF00", 134, 147]
	gosub ReColor
}	

GenSearch(0,0,asw,ash,"CRMEND")


crmLevel = 
	Loop
	{
		Sleep, 50
		ImageSearch, FoundX, FoundY,0,0, 375, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\crmNo.bmp
			if ErrorLevel = 0
				crmLevel = no
		ImageSearch, FoundX, FoundY,0,0, 375, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\crmunresolved.bmp
			if ErrorLevel = 0
				crmLevel = unresolved
		ImageSearch, FoundX, FoundY,0,0, 375, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\crmresolved.bmp
			if ErrorLevel = 0
				crmLevel = resolved
		if (crmLevel <> "")
			break
	}


	reColor:= ["cap", "FFFFFF", 121,226]
	gosub ReColor
	reColor:= ["Ncap", "FFFFFF", 121,226]
	gosub ReColor



capitatedClaim = NO
Loop
{
			Imagesearch, x, y, 0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\CapEND.BMP
				if ErrorLevel = 0
				{
					capitatedClaim = YES
					break
				}
			Imagesearch, x, y, 0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\NCapEND.BMP
				if ErrorLevel = 0
					Break
}

	if (PriorAuthNum = "null")
		priorAuthNum = 

Gui Scan: Destroy

			Gui Scan: Add, Text, center w440, - VALUES FOUND - 
			Gui Scan: Add, Text, center w440, %A_SPACE%
							Gui Scan: Add, text, x10 y50, Claim Number:
							Gui Scan: Add, Button, gAddtoDPL x102 y79, Add to DPL
			Gui Scan: Add, Edit,X10 y79 vclmm , %claimnumber%
				Gui Scan: Add, text, , Prior Auth Number
			Gui Scan: Add, Edit, , %priorAuthNum%
			Gui Scan: add, text, x10 y160, TIN Number:
						Gui Scan: Add, Edit, x10 y180 vTinNumbers, %TIN%
			Gui Scan: Add, button, gCDIDSearch x102 Y180, Search CDID


fileread, region, C:\AutoHotkey\Tapestry\Program data\inOut.txt

loop, parse, regions, `,
	ifinstring, A_LoopFIeld, %zip%
		stringleft, region, A_LoopField, 1

for index in abList
{
	if (region <> "")
	{
		if (region = (abList[A_INDEX]))
			region := decr[A_INDEX]
			
	}
}
if (region = "")
	region = notFound




			Gui Scan: add, text, x10 y210 , `r `nService Facility Region - %Region%

			Gui Scan: Add, text,,`r`n___________________________________________________________________________	
			Gui Scan: Add, Text, center w440, Alerts: 
						
	transFlag = OFF
	esrdFlag = OFF
for index, element in claimAlerts
{
	check:= claimAlerts[A_INDEX]
	if (Check = "transplant")
	transflag = ON
	ifinstring, Check, Replacement Claim
		replacementFlag = ON
	if (check = "End Stage Renal")
		esrdFlag = ON
	
	
}
		if (transFlag = "ON")
		{
			Gui Scan: font, s15
		Gui Scan: Add, text, center w440 CRed, TRANSPLANT DX ON CLAIM
	}
	if TIN contains 956005217,951683892,752694137,952281302,233059262,752919774,956001558,956003843,233059262,952294234
	{
		Gui Scan: Add, text, center w440 CRed, Possible Plan Facility
	}
	
		if (esrdFlag = "ON")
			Gui Scan: Add, text, center w440 CRed, Possible Kidney Transplant / ESRD!

		if (crmLevel = "unresolved")
			Gui Scan: Add, text, center w440 CRed, Unresolved CRM Detected!
	
		if (capitatedClaim = "YES")
			Gui Scan: Add, text, center w440 CRed, CAPITATED CLAIM Detected!
	
	
	
if (replacementFlag = "ON")
		{
			Gui Scan: font, s15
		Gui Scan: Add, text, center w440 CRed, POSSIBLE REPLACEMENT CLAIM DETECTED
	}
	
						Gui Scan: Add, Text, center w440, %A_SPACE%
											Gui Scan: font, s8
						Gui Scan: Add, text,,`r`n___________________________________________________________________________					

						Gui Scan: Add, Text, center w440, Pend/Hold Codes: 
	gosub PodeCodes	
		Gui Scan: Show, w475, Claim Scan
		
return
closeScan:
Gui Scan: Destroy
gosub declarations
createGUI()
}
return



CDIDSearch:

			gosub declarations
			Gui 3: Submit
			Gui 3: Destroy

			Winactivate, Hyperspace
			
			getStyle(Style)
				If (errorChecking = "NO") {
					gosub declarations
					msgbox an Error has occured.
					createGUI()
					return
						}
				t:= Style		; Performs an image search to determine what the style is
				theme:= Style	; Style determines the directory for future searches	
			
			form(t,y)
				If (errorChecking = "NO") {
					gosub declarations
					msgbox An error has occured.
					createGUI()
					return
				}



 For pwb in ComObjCreate("Shell.Application").Windows
{
        urls:= pwb.LocationURL
			Ifinstring, urls, ssl
			{
		ifinstring, urls, .kp.org	; Indicates the current tab group has been found
		{
						name:= pwb.LocationName
			ifnotinstring, name, Connection Center
				 winactivate, %name%
			check:= urls
			break
		}
	}
}
Wb:= iegetbyURL(check)
StringGetPos, number, Check, .kp.org
number += 7
Stringleft, check, check, %number%	; Get the SSL address - eg. SSL.KP , SSL-NDC.KP, etc

StringGetPos, number, check, `.org
number += 4
Stringleft, check, check, %number%

site = %check%/dana/home/launch.cgi?url=http://claimsconnect.kp.org/kpcc/Config/Lists/SCALContractsTracker/Claims.aspx	; form the contract tracker url

find = %check%/kpcc/Config/Lists/SCALContractsTracker/
WW:= iegetbyURL(find)
		text := wW.document.documentElement.innerHTML
		
			ifnotinstring, text, SCAL-Contracts Tracker`" list
			{
				wb.navigate(site, 2048)	; If doesn't exist, open a new tab in the tab group
				Sleep, 300
				Loop
				{
					Wb:= iegetbyURL(find)
					text := wb.document.documentElement.innerHTML	; if not, work off existing
						ifinstring, text, SCAL-Contracts Tracker`" list
							break
					}
				
			}
		else
		{
			 For pws in ComObjCreate("Shell.Application").Windows	; All this activates the current tab
		{
				urlss:= pws.LocationURL
					Ifinstring, urlss, ssl
					{
				ifinstring, urlss, .kp.org
				{
					names:= pws.Hwnd
					ifnotinstring, names, Connection Center
					{
						
						 winactivate, ahk_id %names%
						 winwaitactive, ahk_id %names%
						 Loop
						{
							Sleep, 50
							ifwinactive, SCAL-Contracts Tracker
								Break
							Else
							{
								winactivate, ahk_id %names%
								winwaitactive, ahk_id %names%
								Send, {Ctrl Down}{Tab}{Ctrl Up}
							}
						}
					break
				}
			}
			}
		}
		}


			Loop
			{
				
				Wb:= iegetbyURL(find)
					text := wb.document.documentElement.innerHTML
						ifinstring, text, SCAL-Contracts Tracker`" list
							break
				
			}

var:= text
StringGetPos, number, var, <TD class=s4-wpcell-plain id=MSOZoneCell_WebPartWPQ4 vAlign=top>	; Find element
StringTrimleft, var, var, %number%
StringGetPos, number, var, INPUT name
number += 11
StringTrimLeft, var, var, %number%
StringGetPos, number, var, id=
Stringleft, var, var, %number%

wb.document.getelementbyID("ctl00$m$g_8db428e8_009c_486f_bd2c_523760ca5c41$SPTextSlicerValueTextControl").VALUE:= Tin	; Assign to search
wb.document.getelementbyID("ctl00_m_g_c66edab5_323e_4f7f_8fab_e7763fef70c3_Image").Click()	; Actually search

gosub Declarations
createGUI()
return

return







;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ----------------------------------------CMS / WEBSTRAT SUBS------CMS / WEBSTRAT SUBS-----------------------------------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ----------------------------------------CMS / WEBSTRAT SUBS------CMS / WEBSTRAT SUBS-----------------------------------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v


{ ;----------------------;CMS AND WEBSTRAT----------------------------


parseClaim2:

		Gui 3: Submit
		Gui 3: Destroy
		gosub declarations
		Winactivate, Hyperspace

		getStyle(Style)	; I do these here so it doesn't immediately start looking at Hyperspace before an action is taken in the GUI
				If (errorChecking = "NO") {
			gosub declarations
			msgbox an Error has occured.
			createGUI()
			return
				}
			t:= Style
			theme:= Style
						
			
	navmain("ANSI",t)	; Navigate to ANSI values
	Sleep, 300
	recopyANSI:
	breaker = 0

	GenSearch(0,0,asw,ash,"elImage")	; Wait until image is on screen
	Y += 8
	X += 20
	MOusemove, %X%, %Y%


	Click, Left
	Sleep, 300
	click, down	; Find start
	X += 60

	SetMouseDelay, 40
	MOusemove, %X%, %Y%


	foundX:= (x+120)
	foundY:= y	


	MOusemove, %FoundX%, %FoundY%
	Sleep, 500
	SetMouseDelay, -1
	FoundX:= asw

	Mousemove, %FoundX%, %FoundY%

	breaker = 0
	Loop
	{
		Sleep, 400
	Click Up	; Text selected, copy text
	foundy += 5
	Mousemove, %x%, %y%
	Click, Right
	Loop
	{
		Clipboard = 
		if (clipboard < 0)
			Break
	}
	WartetKopie()

					if (errorChecking = "NO")
						goto recopyANSI
					else
						if (clipboard <> "")
						break
					
					}



	gosub ANSIParse

claimParsed = YES

	if (claimType = "UB")
	{
			Gui Temp: Add, Text,, UB Claim found.
			Gui Temp: Add, Text,, Please enter your WebStrat password.	; If the parse returns there is a ub claim
			Gui Temp: Add, edit, vPass w180 Password,%Pass%				; password entry for webstrat pops up.
			Gui Temp: Add, Button, gWebAuto, Okay						; The okay button navigates to the WebStrat sub.
			Gui Temp: Show
			return
	}

	claimParsed = YES

gosub goautomedi
return

GoAutoMedi:	

Gui 3: Submit
Gui 3: Destroy

if (claimParsed <> "YES")
gosub Declarations

MaxLength(Array)
{
	For each, item in Array
		If (StrLen(item) > MaxLength)
			MaxLength := StrLen(item)
	return MaxLength
}

Global PricedFACILITYPRICE:=  []
Global PricedNONFACILITYPRICE:=  []
Global PricedMODIFIER:=  []
Global PricedHCPCS:= []
reasons:= ["PricedHCPCS","PricedMODIFIER","PricedPROCSTAT","PricedMACLOCALITY","PricedNONFACILITYPRICE","PricedFACILITYPRICE","NONFACILITYLIMITINGCHARGE","FACILITYLIMITINGCHARGE","CONVfACT","NAFLAGFORTRANSNONFACPERVU","NAFLGFORFULLYIMPNONFACPERVU","NAFLAGFORTRANSFACILITYPERVU","NAFLAGFORFULLYIMPFACPERVU","NOTUSEDFORMEDICARE","OPPSNOnFACILITYPAYMENTAMOUNT","OPPSFACILITYPAYMENTAMOUNT"]

;----------------------;AUTOMATIC RBRVS/WEBSTRAT BEGIN ----------------------------

if (claimParsed <> "YES")
	{
		{ ;----------------------;GUI Destruction, parse performed----------------------------
			gosub declarations
			Gui 3: Submit
			Gui 3: Destroy
	
			
			Winactivate, Hyperspace
			
			getStyle(Style)
				If (errorChecking = "NO") {
					gosub declarations
					msgbox an Error has occured.
					createGUI()
					return
						}
				t:= Style		; Performs an image search to determine what the style is
				theme:= Style	; Style determines the directory for future searches	
			
			form(t,y)
				If (errorChecking = "NO") {
					gosub declarations
					msgbox An error has occured.
					createGUI()
					return
				}
				
						;~ msgbox blep
						
		}
		;----------------------;Parse completed----------------------------





		{ ;----------------------; If UB claim is detected, GUI opens for password entry--------
			if (claimType = "UB"){ 
				Gui Temp: Add, Text,, UB Claim found.
				Gui Temp: Add, Text,, Please enter your WebStrat password.	; If the parse returns there is a ub claim
				Gui Temp: Add, edit, vPass w180 Password,%Pass%				; password entry for webstrat pops up.
				Gui Temp: Add, Button, gWebAuto, Okay						; The okay button navigates to the WebStrat sub.
				Gui Temp: Show
				return
			}
		}
		;----------------------;UB Password entry END - Jump to WebAuto---------------------
		
		
		
	}
		
		
		{ ;----------------------;Re-declare iLine array, eliminate duplicate hcpcs from iHCPCS----------------------------
			Global iLine:= {}
			element:= 
			hcpcsFiltered:= []
				for index in iHCPCS
				{
			
					hcpcs:= StrReplace(iHCPCS[A_INDEX],A_SPACE)
					ifnotinstring, element, %hcpcs%
					{
						hcpcsFiltered.Push(hcpcs)	; New array for unqiue codes
					
					}
					
					element = %element% %hcpcs%
					
				}
			
		}


			if (Date = "")
			date:= iFromdate[1]
			dateCheck:= Strlen(Date)
			if (dateCheck <> 10)
			{
				dateFormat(iFromDate[1])	; Set to universal 4 digit year format
				StringLeft, Year, outPutDate, 4	; The first 4 digits are the year
			}
			else
				StringRight, year, date, 4
			
			
			
			
			
			ieClose("Physician Fee Schedule Search")	; check for page
			
				if (errorChecking = "NO") {
					wsBreak()
					return
				}
				
			ieClose("https://www.cms.gov")	; check for page
				if (errorChecking = "NO") {
					wsBreak()
					return
				}
			If (Year = 2018)	; Determine what URL to use
				Run, Iexplore.exe https://www.cms.gov/apps/physician-fee-schedule/search/search-results.aspx?Y=0&T=0&HT=1&CT=2&H1=+&H2=+&H3=+&H4=+&H5=+&C=1&M=5
			If (year = 2017)
				Run, Iexplore.exe https://www.cms.gov/apps/physician-fee-schedule/search/search-results.aspx?Y=1&T=0&HT=1&CT=2&H1=+&H2=+&H3=+&H4=+&H5=+&C=1&M=5				
			If (year = 2016)
				Run, Iexplore.exe https://www.cms.gov/apps/physician-fee-schedule/search/search-results.aspx?Y=2&T=0&HT=1&CT=2&H1=+&H2=+&H3=+&H4=+&H5=+&C=1&M=5
			
			SeiteBrecher("Physician Fee Schedule",600)
				if (errorChecking = "NO") {
					WSBreak()	; Error handling
					return
				}
			

			
		{ ;----------------------;Waits until trademark page is cleared----------------------------
			unterBrecher = 0
			Loop
			{
				wb := IEGet("Physician Fee Schedule Search")
				text := wb.document.documentElement.innerHTML
				
					Ifinstring, text, All rights reserved. CPT is a registered trademark of the American Medical	; Check for trademark
					{
						try	; The "try" keeps it from erroring out
							wb.document.getElementsByTagName("A")[28].Click()	; Accepts and continues if not on search
						While wb.busy or wb.ReadyState != 4
							Sleep, 1
						text := wb.document.documentElement.innerHTML
							Ifinstring, text, Selected Criteria
								break
					}
				;-------------------------------------------------------------
				
				
				
				wb := IEGet("Physician Fee Schedule Search Results")
				text := wb.document.documentElement.innerHTML
					Ifinstring, text, Selected Criteria	; only present on search page
						break
					if (unterBrecher > 700)
						Break	; into error catch below if not found
				unterBrecher += 1
				
				
			}
		}
			;----------------------;Starts from the search results page----------------------------
			
			
			if (unterBrecher > 700) {
				wsBreak()
				return
			}
			

			fileRead, var, C:\Autohotkey\Tapestry\Program Data\zipTranslations.txt
			Global Var:= 
			;~ zipCodeTranslations()
			
				Ifinstring, var, %zipCode%
				{
					StringGetPos, NUmber, var, %zipCode%
				Number += 6
				StringTrimleft, var, var, %number%
				StringGetPos, number, var, `;
				Stringleft, loc, var, %number%
			}
			else
				loc = ERROR
			{ ;----------------------;Select Location----------------------------
				Loop
				{	; This loops the index through possible values until a match to the translation is found
					wb.document.getElementsByTagName("Select")[6].selectedindex:= A_INDEX
					LOC2:= wb.document.getElementsByTagName("Select")[6].Value
						If (LOC = LOC2)
							break
						If (A_INDEX = 110)
								LOC = 0118299
						If (Check = LOC)
							break
				}
					wb.document.getElementsByTagName("Select")[6].fireEvent("onchange")
					wb.document.getElementsByTagName("Select")[4].Value:= `%	; Sets modifier to default
			}
			
			Loop
			{

				var:= wb.document.documentElement.innerHTML
				StringGetPos, number, var, HCPCS:
				StringTrimLeft, var, var, %number%
				hcpcsCounter = 1	
					
				Loop, 5
				{
					element:= var
					StringGetPos, number, var, for
					number += 5
					StringTrimleft, var, var, %number%
					StringTrimleft, element, element, %number%
					StringGetPos, number, element, `"
					Stringleft, element, element, %number%
					
					wb.document.getElementbyID(element).value:= hcpcsFiltered[hcpcsCounter]
					hcpcsCounter += 1
				}
					wb.document.getElementsbyTagName("A")[34].Click()
						While wb.busy or wb.ReadyState != 4
							Sleep, 1
								var:= wb.document.documentElement.innerHTML
								StringGetpos, NUmber, var, PAYMENT AMOUNT<sup>1</sup>
								StringTrimleft, var, var, %number%
								StringGetPos, number, var, <td>
								StringTrimleft, var, var, %Number%
								StringGetPos, number, var, <td colspan	; Pull out elements and parse values
								Stringleft, var, var, %number%
								Stringreplace, var, var, &nbsp;,%A_SPACE%,all
								Stringreplace, var, var, </tr>, ,all
								Stringreplace, var, var, <tr class="alternatingGridviewRow">,,all
								Stringreplace, var, var, <tr class="gridviewRow">,,all
								Stringreplace, var, var, class="alternatingGridviewRow">,,all
								Stringreplace, var, var, <tr>,,all
								Stringreplace, var, var, <tr,,all
								Stringreplace, var, var, </td>,|,all
								Stringreplace, var, var, <td>,,all
								Stringreplace, var, var, `n,`r,all
								Stringreplace, var, var, `r,,all
								Stringreplace, var, var, %A_TAB%,,all
								Loop, parse, var, 
									Loop, Parse, A_LoopField, |
									{
										toGroup:= reasons[A_INDEX]
										%toGroup%.Push(A_LoopField)
									}
						
if (hcpcsCounter >= maxLength(hcpcsFiltered))
				break
			}
					Gui, Add, ListView, vLV1  w400 h175, HCPCS Code|Modifier|Facility Price|Non-Facility Price
		for index in PricedFACILITYPRICE
		{
			fac:= PricedFACILITYPRICE[A_INDEX]
			Nonfac:= PricedNONFACILITYPRICE[A_INDEX]	; 
			hcpcsCode:= PricedHCPCS[A_INDEX]
			hcpcsModi:= PricedMODIFIER[A_INDEX]
			
			Gui, ListView, LV1
				LV_Add("", hcpcsCode,hcpcsModi,fac,nonFac)
		}
		Gui, Add, Button, gClosePricer,Exit
		
		Gui, Show
		return
		}

closePricer:
Gui, Destroy
CreateGui()
return



;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ---------------------WEBSTRAT-------------------WEBSTRAT-------------------WEBSTRAT--------------------WEBSTRAT--------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ---------------------WEBSTRAT-------------------WEBSTRAT-------------------WEBSTRAT--------------------WEBSTRAT--------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v



WebAuto:


{ ;----------------------;WebStrat Search Start----------------------------
	Gui Temp: Submit
	Gui Temp: Destroy

	
{ 	;----------------------;Converting dates from the parse into acceptable format----------------------------
	dateFormatWS(fromDate)
	fromDateWS:= outPutDate
	dateFormatWS(toDate)
	toDateWS:= outPutDate
	rCheck:= 
	ifnotinstring, dob, `/
	{
		Stringreplace, dob, dob,,%A_SPACE%,all
		Stringreplace, dob, dob, %A_SPACE%,,all
		Stringleft, day, dob, 4
		StringRight, month, day, 2
		Stringleft, day, day, 2
		StringRight, year, dob, 4
		
		dob = %day%/%month%/%year%
	}
	if (LOS = 0)
		LOS = 1

}
		;----------------------;Dates converted----------------------------


{ ;----------------------;Logic to close WebStrat if open, open when it is fully closed----------------------------
	
	ieClose("Web.Strat")	; Attempt to close WebStrat if already open
		if (errorChecking = "NO") {
			WSBreak()	; Error handling
			return
		}
;-------------------------------------------------------------
	Run, iexplore.exe https://Optum.webstrat.com/HSS/WebStrat/login.aspx
	unterBrecher = 0
;-------------------------------------------------------------
		SeiteBrecher("Web.Strat Login",600)
		if (errorChecking = "NO") {
			WSBreak()	; Error handling
			return
		}

		wb := IEGet("Web.Strat Login")

			While wb.ReadyState != 4
				Sleep, 1
		
}
	;----------------------;WebStrat opened, ready to login----------------------------


{ ;----------------------;Logging in----------------------------
	wb.document.all.TextBoxUserId.value:= User
	wb.document.all.TextBoxPassword.value:= Pass	; Login. User is the NUID saved when the user starts the first time
	wb.Document.All.ButtonLogin.Click()
	unterBrecher = 0
	
	while (rCheck <> 131)
	{
		try,
			wb := IEGet("Web.Strat")
		try
			RCheck:= wb.document.parentwindow.frames[8].document.getelementsbytagname("INPUT")[27].value
				If (RCheck = 131)	; This ensures the page fully loads before continuing.
					break
				if (unterBrecher > 4000)
					break
		unterBrecher += 1
	}

		if (unterBrecher > 4000) {
			WSBreak()	; Error handling
			return
		}
}		
	;----------------------;WebStrat Logged in----------------------------




{	 ;----------------------;Declaring names----------------------------
	cInput:= wb.document.parentwindow.frames[8].document.getelementsbytagname("INPUT")
	cSelect:= wb.document.parentwindow.frames[8].document.getelementsbytagname("SELECT")
}
		;-------------------------------------------------------------

{ ;----------------------;Insuring Patient Type changes before contuing----------------------------

	cSelect[0].selectedIndex := Ptype ; Patient Type
	cSelect[0].fireEvent("onchange")	; ensure it changes before continuing. There were issues.
	unterBrecher = 1

		Loop, 
		{
			Check:= cInput[4].value
				if (Check > 0 OR unterBrecher > 500)
				break
			unterBrecher += 1
		}
		
			if (unterBrecher > 500) {
				WSBreak()	; Error handling
				return
			}
		
	Check:= 
	unterBrecher:= 
}
	;----------------------;Patient Type changed. Screen layout will not change further----------------------------


;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ------------CLAIM LEVEL-------------------CLAIM LEVEL-------------------CLAIM LEVEL--------------------CLAIM LEVEL-----------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v



{ ;----------------------;Assigning claim-level values----------------------------
	cInput[13].value:= A_SPACE ; MRN
		cInput[13].fireEvent("onchange")
	;-------------------------------------------------------------	
	cInput[26].value:= DSTATUS ; Dis Stat
		cInput[26].fireEvent("onchange")
;-------------------------------------------------------------	
	cInput[5].value:= NPI ; NPI
		cInput[5].fireEvent("onchange")
;-------------------------------------------------------------			
	cInput[27].value:= Billtype ; BILL TYPE
		cInput[27].fireEvent("onchange") ; BILL TYPE
;-------------------------------------------------------------			
	cSelect[4].fireEvent("onchange")
;-------------------------------------------------------------			
	cInput[16].value:= LOS ; LOS
		cInput[16].fireEvent("onchange")
;-------------------------------------------------------------			
	cInput[14].value:= FromDateWS ; DATE FROM
		cInput[14].fireEvent("onchange")
;-------------------------------------------------------------			
	cInput[15].value:= ToDateWS ; DATE THROUGH
		cInput[15].fireEvent("onchange")
;-------------------------------------------------------------			
	cInput[22].value:= Sex ; Sex
		cInput[22].fireEvent("onchange")
;-------------------------------------------------------------			
	cInput[11].value:= "09" ; Payer ID
		cInput[11].fireEvent("onchange")
;-------------------------------------------------------------			
	cSelect[3].Value:= "09"
	cInput[28].Value:= TotalCharges
;-------------------------------------------------------------		
		cInput[28].fireEvent("onchange")
		cSelect[3].fireEvent("onchange")
		wb.document.parentwindow.frames[8].document.getelementsbytagname("SELECT")[2].selectedIndex:= 1
		wb.document.parentwindow.frames[8].document.getelementsbytagname("SELECT")[2].fireEvent("onChange")
;-------------------------------------------------------------			
	cInput[25].value:= DOB ; DOB
		cInput[25].fireEvent("onchange")
	;-------------------------------------------------------------		
		cInput[11].fireEvent("onchange")
;-------------------------------------------------------------	
	cInput[11].fireEvent("onchange")
		cInput[11].fireEvent("onchange")
		cInput[11].focus()
		Controlsend, , {TAB}, Web.Strat
}
;----------------------;Claim level values assigned----------------------------

{ ;----------------------;Changing to line-level view----------------------------

	wb.document.getElementsbyTagName("TabStrip")[0].focus()
		Controlsend, Internet Explorer_Server1,{Left},Web.Strat
	Text:= wb.document.getelementsbyname("ButtonToggleHCPCS")[].value
		If (Text = "Show HCPCS")
			wb.document.getElementsByTagName("Input")[35].Click()
}
	;----------------------;Screen changed----------------------------

;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ------------DX ENTRY-------------------DX ENTRY-------------------DX ENTRY--------------------DX ENTRY-----------------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v

	DXLIST = DXXX	

	for index, element in iDX
	{	; DX Codes
		dx:= iDX[A_INDEX]		; Dump in from the array
			ifinstring, DX, `-
				break
		POA:= iPOA[A_INDEX]
			
			IfinString, DXLIST, %DX%	; If a duplicate DX is encountered, it's done.
			break
			
		wb.document.parentwindow.frames[0].document.getelementsbyname("DX"(A_INDEX - 1))[].value:= DX
		wb.document.parentwindow.frames[0].document.getelementsbyname("DX"(A_INDEX - 1))[].fireEvent("onChange")
			if (POA > 0) {
			wb.document.parentwindow.frames[0].document.getelementsbyname("onset"(A_INDEX - 1))[].value:= POA
		}
			wb.document.parentwindow.frames[0].document.getelementsbyname("onset"(A_INDEX - 1))[].fireEvent("onChange")
		Sleep, 600
		DXLIST = %DXLIST% %DX%	; Add the DX to a rolling list
		DX = 
		POA = 	; Empty these for safety
	}
	
	



;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ------------LINE  LEVEL-------------------LINE  LEVEL-------------------LINE  LEVEL--------------------LINE  LEVEL-----------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v


	

			RVAR = 0
			dateFormatWS(fromDate)
			fromDateWS:= outPutDate


	for index, element in iRev
	{	; Rev Codes
			
				breakCheck:= iRev[A_INDEX]
					Stringreplace, breakCheck, breakCheck, %A_SPACE%,,all
					Stringreplace, breakCheck, breakCheck, %A_TAB%,,all
					
			ifnotinstring, breakCheck, 0
				break
				
				
				
			Charge:= iCharges[A_INDEX]	
			Dates:= iSDATE[A_INDEX]
				
				
				
			Stringreplace, Charge, Charge, `,,,all
			
			if (dates > 0)
			{
				dateFormatWS(dates)
				Dates:= outPutDate
			}
			if (Dates < 0)
				dates:= fromDateWS
			
			wb.document.parentwindow.frames[4].document.getelementsbyname("rev"(A_INDEX -1))[].value:= iRev[A_INDEX]
			wb.document.parentwindow.frames[4].document.getelementsbyname("rev"(A_INDEX -1))[].fireEvent("OnChange")
			wb.document.parentwindow.frames[4].document.getelementsbyname("hcpcs"(A_INDEX -1))[].value:= iHcpcs[A_INDEX]
				
				
				if ((StrLen(iModi[A_INDEX])) = 2)
					wb.document.parentwindow.frames[4].document.getelementsbyname("m1"(A_INDEX -1))[].value:= iModi[A_INDEX]			; Dump in the values
				else
				{
					mod:= iModi[A_INDEX]
					Stringleft, Mod1, mod, 2
					StringRight, Mod2, mod, 2
					wb.document.parentwindow.frames[4].document.getelementsbyname("m1"(A_INDEX -1))[].value:= mod1
					wb.document.parentwindow.frames[4].document.getelementsbyname("m2"(A_INDEX -1))[].value:= mod2
				}
			wb.document.parentwindow.frames[4].document.getelementsbyname("Date"(A_INDEX -1))[].value:= dates
					
			wb.document.parentwindow.frames[4].document.getelementsbyname("Units"(A_INDEX -1))[].value:= iCounters[A_INDEX]
					
			wb.document.parentwindow.frames[4].document.getelementsbyName("charges"(A_INDEX -1))[].value:= Charge	
					
			wb.document.parentwindow.frames[4].document.getelementsbyname("physNo"(A_INDEX -1))[].focus()	; This is important. It opens up the next line, for whatever reason
					
			wb.document.parentwindow.frames[4].document.getelementsbyname("physNo"(A_INDEX -1))[].fireEvent("onchange")
		
		
		
	}
	



;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ------------Procedure Codes-------------Procedure Codes-----------Procedure Codes------------------Procedure Codes-----------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v

	for index, element in iProcedure
	{	
		procedure:= iProcedure[A_INDEX]
		procdate:= (iProcDate[A_INDEX])
		procDate:= (StrReplace((StrReplace((StrReplace((iProcDate[A_INDEX]),"`n")),"`r")),A_SPACE))
		
				Stringreplace, procDate, procDate, `r,,all
				Stringreplace, procDate, procDate, `n,,all
				Stringreplace, procDate, procDate, %A_SPACE%,,all
				
		dateFormatWS(procDate)
		procDate:= outPutDate
			
			wb.document.parentwindow.frames[2].document.getelementsbyname("Px"(A_INDEX -1))[].value:= Procedure
				wb.document.parentwindow.frames[2].document.getelementsbyname("Px"(A_INDEX -1))[].fireEvent("onchange")	; Dump stuff in
				
			wb.document.parentwindow.frames[2].document.getElementById("PxDate"(A_INDEX -1)).value:= procDate
				wb.document.parentwindow.frames[2].document.getElementById("PxDate"(A_INDEX -1)).fireEvent("onChange")
				
		ProcDate = 
		Procedure = 

	}	



		wb.document.getelementsbytagname("A")[15].click()



{ ;----------------------;Experimental. This will actually return the price most of the time.----------------------------

}
;----------------------;End experimental code----------------------------

	gosub declarations
	createGUI()
	return




}	



	;----------------------;End CMS AND WebStrat----------------------------


;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ----------------------------------------PERCENT BILLED SUB------PERCENT BILLED SUB-------------------------------------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ----------------------------------------PERCENT BILLED SUB------PERCENT BILLED SUB-------------------------------------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v


GoPercent:
{
	
	
	
		Gui 3: Submit
		Gui 3: Destroy
		gosub declarations
		Winactivate, Hyperspace
		Winwaitactive, Hyperspace
		getStyle(Style)	
				If (errorChecking = "NO") {
			gosub declarations
			msgbox an Error has occured.
			createGUI()
			return
				}
			t:= Style
			theme:= Style
						
{	;----------------------;Gui Desctruction and navigation to page----------------------------
		
	
	ifwinexist, Service Level Overrides,
	{
		Winactivate, Service Level Overrides
		Winwaitactive, Service Level Overrides
		reColor:= ["closeService", "ffffff", 30, 28]	; Get pixel color to modify source images for dynamic background colors
		gosub ReColor
			GenSearch(0,0,asw,ash,"closeServiceEND")	; Find the re-colored image
		Mousemove, %X%, %Y%
			Loop, 20
			Click, left	
	}

	Winactivate, Hyperspace
	Winwaitactive, Hyperspace

	

	navmain("adjReview",t)
			If (errorChecking = "NO") {
				gosub declarations
				msgbox an Error has occured.
				createGUI()
				return
					}
	}


	Winactivate, Hyperspace
	winwaitactive, Hyperspace




	Gui Percent: add, Edit, vPercentageMAIN, 100`%
	Gui Percent: add, Text, x50 Y8, Whole claim Percentage
		Gui Percent: add, Button, gGoGetIt, Price Claim
	Gui Percent: show ;, H%HX%
	
	return
	
	
	goGetIt:
		Gui Percent: Submit
		Gui Percent: Destroy
		Winactivate, Hyperspace
		winwaitactive, Hyperspace		


	reColor:= ["svcAM", "FFEA00", 378, 123]
	gosub ReColor
	
	GenSearch(0,0,asw,ash,"SVCAMEND")
	
	Mousemove, %x%, %y%
		Click, Left
		
	Winwaitactive, Service Level Overrides

	totalVar = 0
	Winwaitactive, Service Level Overrides

	reColor:= ["next", "ffffff", 116, 28]
	gosub ReColor

	reColor:= ["nextsel", "ffffff", 116, 28]
	gosub ReColor

	reColor:= ["nextDown", "ffffff", 116, 28]	; Once the window is open, take pixel color from the background and apply it to all the source images for imagesearch
	gosub ReColor

	reColor:= ["noNext", "ffffff", 116, 28]
	gosub ReColor

	reColor:= ["zeros", "FF0000", 116, 28]
	gosub ReColor

	reColor:= ["bldAMT", "CDC71B", 116, 28]
	gosub ReColor

	reColor:= ["SvcLine", "FFFFFF", 116, 28]
	gosub ReColor	

	reColor:= ["prev", "FFFFFF", 30, 28]
	gosub ReColor					
				
	reColor:= ["noPrev", "FFFFFF", 30, 28]
	gosub ReColor
	
	TotalSum = 0
	totalCalculated = 0
	
	Coordmode, Pixel, relative
	coordmode, mouse, relative
	SetMouseDelay, -1
	ANUmber = 0
	Sleep, 0
	pcNumber = 1
	end = off
	unterBrecher = 0	; Declare stuff
	currentLine = 1
	Loop
	{
		
		
		
		global processed:=		
		
		Loop
		{
			ocrX = 77
			ocrY = 30	; Coordinates for "Line NUmber X:"
			ocrW = 45
			ocrH = 20
			Loop
			{
				gosub OCR	; Get text from screenshot
				Stringreplace, OCRText, OCRText, %A_SPACE%,,all
				Stringreplace, OCRText, OCRText, `r,,all
				Stringreplace, OCRText, OCRText, `n,,all
			if ocrText
				break
			}
			Stringreplace, ocrText, ocrText, :,,all	; Wait to continue until the line number matches what line is being processed
			if (ocrText = currentLine)
				break
		}	
			
			Loop 
			{	; Determine whether line is the last line or not
				ImageSearch, Xx, Yy,0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\nextselEND.bmp
				if ErrorLevel = 0
				break
				
				ImageSearch, Xx, Yy,0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\nextEND.bmp
				if ErrorLevel = 0
				break
				
				ImageSearch, Xx, Yy,0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\noNextEND.bmp
				if ErrorLevel = 0
				{
					End = ON
					break
				}
				
				unterBrecher += 1
				if (unterBrecher = 50)
				{
					
					reColor:= ["nextsel", "ffffff", 30, 28]
					gosub ReColor
					
					reColor:= ["next", "ffffff", 30, 28]
					gosub ReColor
					
					reColor:= ["nextDown", "ffffff", 30, 28]
					gosub ReColor
					
					reColor:= ["Nonext", "ffffff", 30, 28]
					gosub ReColor
					
					reColor:= ["zeros", "FF0000", 30, 28]
					gosub ReColor
					
					reColor:= ["prev", "FFFFFF", 30, 28]
					gosub ReColor	
					
					reColor:= ["SvcLine", "FFFFFF", 30, 28]
					gosub ReColor					
					
					reColor:= ["noPrev", "FFFFFF", 30, 28]
					gosub ReColor
						unterbrecher = 0
				}		
				
				
			}	
			
				ImageSearch, x, Y,0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\drgEND.bmp	; Non-Payable
					if ErrorLevel = 0
						drg = FOUND
					
					skip = NO
					
					
					pixelGetColor, pc, 802, 120, SLOW	; If the pixel here is not white, text is not enterable. Line is denied.
					if (pc <> "0xFFFFFF")
						skip = YES
						
				if (drg <> "FOUND")
				{	
					
					if (SKIP = "NO")
					{
					
							
								ocrX = 126
								ocry = 635
								ocrW  = 90	;Coordinates for billed charges
								ocrH =  20
								Loop
								{
									gosub OCR	; Perform OCR for billed charges
									Stringreplace, OCRText, OCRText, %A_SPACE%,,all
									Stringreplace, OCRText, OCRText, `r,,all
									Stringreplace, OCRText, OCRText, `n,,all
								if ocrText
									break
								}
							
							
						var:= ocrText
						
						
						Mousemove, 756, 105	; to enter text
						Click, Left
						
						Loop
						{
							ImageSearch, X, Y,0, 0, 1000, 1000, C:\AutoHotkey\Tapestry\Generic\textENTER.BMP
							if ErrorLevel = 0
								break
							pixelGetColor, ccv, 782, 119, rgb	; Wait for text to be enterable
							pixelGetColor, ccd, 262, 691, rgb
							if (CCV = ccd)
								break
							
						}
						
						Stringreplace, percentageMain, percentageMain, `%,,all	; Just in case
							cc:= (var * (PercentageMAIN * .01))						; Perform calculations
							TotalSum:= (TotalSum + ocrText)
							totalCalculated:= Round((totalCalculated + CC),2)
							
							if (END = "ON")
								cc:= (cc + ((Round((TotalSum * (PercentageMAIN * .01)),2)) - totalCalculated))
							
						if (CC > 0)
						{
							Loop
							{
								ImageSearch, X, Y,649, 89, 1000, 1000, C:\AutoHotkey\Tapestry\Generic\textENTER.BMP
								if ErrorLevel = 0
									break
								pixelGetColor, ccv, 782, 119, rgb
								pixelGetColor, ccd, 262, 691, rgb
								if (CCV = ccd)
								{
									cc = 0
									break
								}
							}
							;~ exitapp
							;~ return
								if (End = "ON")
									Sleep, 300
								Send, %cc%{TAB}		; Send text

								Loop
								{
									ImageSearch, X, Y,0, 0, 1000, 1000, C:\AutoHotkey\Tapestry\Generic\textENTER.BMP
									if ErrorLevel = 0
										break
								}
								Sleep, 200
								Ifwinactive, AP Claims Code Editor	; Window may sometimes appear
									{	
										Send, Y
										Sleep, 700
										WinwaitActive, Service Level
									}
								Winwaitactive, Service Level
								Sleep, 300
																;~ msgbox % cc
								Send, ADMIN	; Set reason code
								Sleep, 100
								Send, {TAB}
								Loop
								{
									Ifwinactive, AP Claims Code Editor
									{	
										Send, Y
										WinwaitActive, Service Level
									}
									ImageSearch, X, Y,0, 0, 1000, 1000, C:\AutoHotkey\Tapestry\Generic\textENTER.BMP
									if ErrorLevel = 0
										break
								}
								
							
							
							
						}
					}
					
					
					DRG = nullValue
					pcNumber += 1
				}
				else
					drg = nullValue
			
			
			Winwaitactive, Service Level Overrides 
			
			reCheck:
			
			if (skip = "NO" AND END <> "ON")
			{
				Mousemove, 360, 38
				Sleep, 100
				Click, Left
				mouseGetPos, chheckX,chhecky
				if chheckX > 360 OR chhecky > 39	; Move mouse to position
					goto reCheck
				
				selCounter = 0
				Loop
				{
					ImageSearch, X, Y,0, 0, 182, 45, C:\AutoHotkey\Tapestry\Generic\sldBlue.BMP	; Wait until text properly selected
						if ErrorLevel = 0
						break
						if selCounter > 50
							goto reCheck
						selCounter ++
				}
							
				Loop
				{
					ImageSearch, X, Y,0, 0, 922, 98, C:\AutoHotkey\Tapestry\Generic\prevEND.BMP	; Determine how many times to tab
						if ErrorLevel = 0
						{
							send, {Tab 2}	; Subsequent lines
							break
						}
					ImageSearch, X, Y,0, 0, 922, 98, C:\AutoHotkey\Tapestry\Generic\noprevEND.BMP
						if ErrorLevel = 0
						{
							send, {Tab}	; First line
							break
						}
				}
			}
			
		currentLine ++
		if  (END <> "ON")
		Send, {SPACE}		; next
		
		if (END = "ON")
			break
	}				

	reColor:= ["closeService", "ffffff", 30, 28]
	gosub ReColor
	
	Mousemove, 788, 707	; On last line, close the pricing window
	Loop, 20
		Click, left	
			

		
	;~ Msgbox Please manually check for rounding errors.	
			
			
			
Gosub declarations
CreateGUI()

return
}
		

;----------------------;Percent DONE----------------------------


;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; -----------------------------------PEND CODES---------------------------PEND CODES-------------------------------------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v

; Has been made impossible by system updates
;------------------PEND CODES ARE NOT ORGANIZED.-------------------------------------------

PodeCodes:

{ ;----------------------;Search for Pend Codes----------------------------


gosub declarations
fileread, masterCompare, C:\AutoHotkey\Tapestry\Program Data\allcodes.txt

StringGetPos, number, masterCompare, `&startNoWork
StringTrimleft, noWorkList, masterCompare, %number%
StringLeft, masterCompare, masterCompare, %number%


{ ;----------------------;GUI Destruction, Hyperspace navigation----------------------------
	Clipboard = 
	Gui 3: Submit
	Gui 3: Destroy
	Winactivate, Hyperspace
	getStyle(Style)
		If (errorChecking = "NO") {
			gosub declarations
			msgbox an Error has occured.
			createGUI()
			return
				}
	t:= Style		; Performs an image search to determine what the style is
	theme:= Style	; Style determines the directory for future searches	
	navmain("adjReview",t)
		If (errorChecking = "NO") {
			gosub declarations
			msgbox an Error has occured.
			createGUI()
			return
				}
}
;----------------------;Adj Review screen populated----------------------------

{ ;----------------------;Search for starting position w/ error handling----------------------------
	unterBrecher = 0
	Loop
	{
		ImageSearch, Xx, Yy,0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\%Theme%\navigation\adjCT.BMP	; Two places recognized from this - Very top and right before Pend/Holds
			if ErrorLevel = 0
				break
			if (unterBrecher > 200)
			{
				gosub declarations
				msgbox an Error has occured.
				createGUI()
				return
			}
		unterBrecher += 1
	}
}
;----------------------;Starting position Found----------------------------

;----------------------;  ----------------------------



	reColor:= ["totalSTART", "FF0000", xx, yy]
	gosub ReColor


	navmain("adjReview",t)
Sleep, 0
;----------------------;----------------------------

{ ;----------------------;Page scroll start----------------------------
	
	Winactivate, Hyperspace
	winwaitactive, Hyperspace
	Mousemove, %X%v, %Yy%
	Loop, 3
		Click, Left
	Mousemove, %XX%, %YY%
	Sleep, 200
	Click Down
	xx += 2
	Yy += 2
	Mousemove, %Xx%, %yY%	; Wiggle the mouse to get the select to take
	Loop, 150
		Send, {WheelDown}	; Get to the bottom of the page
	totalSelector = 1	; Variable to determine the name of the image being searched
	unterBrecher = 0
	found = no
	xStarting = 0
	yStarting = 0
		Loop
		{
			ImageSearch, X, Y,%xStarting%,%YStarting%, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\totalALT.bmp
				if ErrorLevel = 0
					break
				ImageSearch, X, Y,%xStarting%,%YStarting%, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\totalALT2.bmp
				if ErrorLevel = 0
					break
		ImageSearch, X, Y,%xStarting%,%YStarting%, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\totalEND.bmp
				if ErrorLevel = 0
				{
						xTemp:= (x - 23)
						yTemp:= (y + 1)
						Sleep, 300
						Mousemove, %x%, %Y%
						PixelGetColor, color2, %xTemp%, %yTemp%, slow, rgb
						if (Color2 = ColorBackup OR found = "YES")
							break
						
							Loop, 150
								Send, {WheelDown}	; Get to the bottom of the page
								found = YES
							YStarting:= (Y + 2)
							Sleep, 200	
				
				}
			if (unterBrecher > 200)
			{
				gosub declarations
				msgbox an Error has occured.
				createGUI()
				return
			}

		}
			x2:= x
			y2:= y
			X += 15
			Y += 90
			mousemove, %X%, %Y%

} ;----------------------;Page Scroll End----------------------------


{ ;----------------------;Check for bottom again to prevent issues----------------------------
	totalSelector = 1
	unterBrecher = 0
	Mousemove, %X%, %Y%
	
	Loop
	{
		ImageSearch, X, Y,0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\totals2.bmp
				if ErrorLevel = 0
					break
			}
	Click, Up

	
	Loop 
	{
		ImageSearch, X, Y,0 , 0, %A_ScreenWidth%, %A_ScreenHeight%, C:\AutoHotkey\Tapestry\Generic\totals2.bmp
				if ErrorLevel = 0
					break
			}		
	
	y += 3
	Mousemove, %x%, %y%
	Clipboard = 
}
;----------------------;Page scroll completed----------------------------

{ ;----------------------;Copy clipboard and assign to variables----------------------------

	WartetKopie()
masterVar:= Clipboard
	var:= Clipboard
}
;----------------------;Clip assigned----------------------------

		Clean(Var)
	GetLF(Var, "Outstanding Claim Codes (Back to Top)", CUT, Number,Y)
		Trim(Var,Number)
	GetLF(Var, "Diagnosis (Back to Top)", CUT, Number,N)
		StringLeft, Var, Var, %Number%	; Start searching
	Global claimlevel:= {}
	Loop, 
	{
		ifinstring, Var, %A_SPACE%%A_INDEX%`.%A_SPACE%
			Stringreplace, Var, Var, %A_SPACE%%A_INDEX%`.%A_SPACE%,%A_SPACE%`|%A_SPACE%,all	; Replace this string of letters w/ delimiter
				else
					break
	}

;----------------------;Ready to start parsing----------------------------


{ ;----------------------;All claim level codes accounted for, beginning line level code parse----------------------------
		var:= masterVar
		Clean(var)
			Stringreplace, var, var, Pend`,,|,all
			Stringreplace, var, var, HOLD`,,|,all
			Stringreplace, var, var, `- `|,`- `|,UseErrorLevel
				pendCount:= ErrorLevel
				
			Loop, %PendCount%
			{
				StringGetPos, number, var, `- `|
					maxNum:= (number + 3)
					number += -6
				StringTrimLeft, temp, var, %Number%
				StringTrimLeft, var, var, %maxNum%
				StringGetPos, number, temp, %A_SPACE%
				Stringleft, temp, temp, %number%
				ifnotinstring, masterListicle, %Temp%
					if (Temp <> "" AND TEMP <> " ")
					phCodes.Push(temp)
				for index, element in phCodes
					masterListicle:= masterListicle "," phCodes[A_INDEX]
			}		
				
	
}
	;----------------------;Line Level codes accounted for----------------------------	
		
		
		
		
			for index, element in phCodes
			{
				code:= phCodes[A_INDEX]
				Code := regexreplace(Code, "^\s+")
				Code := RegExReplace(Code, "\s*$")
				StringGetPos, number, masterCompare, %Code%`;
					if (number < 0)
						ccNumber.Push(code)
					else
					ccNumber.Push(number)
			}


		for index, element in ccNumber
		{
			numList:= numlist "," ccNumber[A_INDEX]
		}
		StringTrimleft, numList, numList, 1
		Sort, numList, N D,	
			
			Loop, Parse, numList, `,
			{
				if A_LoopField is number
				{
				StringTrimLeft, temp, masterCompare, %A_LoopField%
				StringGetPos, number, temp, %A_TAB%
				
				Stringleft, code, temp, %Number%
					ccCode.Push(code)
				number += 1
				
				StringTriMleft, temp, temp, %number%
				StringGetPos, number, temp, %A_TAB%
				StringLeft, pool, temp, %Number%
					ccPool.Push(pool)
				Number += 1
				
				StringTrimLeft, temp, temp, %Number%
				StringGetPos, number, temp, %A_Tab%
				Stringleft, resp, temp, %number%
					ccResp.Push(resp)
				Number += 1
				
				Stringtrimleft, temp, temp, %Number%
				StringGetPos, number, temp, %A_Tab%
				Stringleft, url, temp, %number%
					ccURL.Push(URl)
			}
			else
			{
				ccURL.Push("NA")
				ccResp.Push("NOT FOUND")
				ccPool.Push("NOT FOUND")
				ccCode.Push(A_LOopField)
			}
		}
			

	for index, element in ccCode
	{
		Code:= ccCode[A_INDEX]
		pool:= ccPool[A_INDEX]
		resp:= ccResp[A_INDEX]
		url:= ccURL[A_INDEX]
		
	}

	;----------------------;All codes added to 'lineLevel' array----------------------------
	
	Gui Scan: Add, text,, All codes listed below are in the order they appear in the Distrobution Scheme.`rCodes highlighted in blue can be clicked to access the DLP. Codes in Red may not be workable.`r`n
	For index, element in ccCode
	{
		code:= ccCode[A_INDEX]
		url:= ccURL[A_INDEX]
		Pool:= ccPool[A_INDEX]
		resp:= ccResp[A_INDEX]
		
		Stringleft, codeCheck, code, 5
			ifinstring, noWorkList, %CodeCheck%
			{
			if (url <> "NA")
			Gui Scan: Add, text, cred gCodeGo%A_INDEX%, %Code%`r`n%A_TAB%%resp% `- %Pool%
			else
				Gui Scan: Add, text,cRed, %Code%`r`n%A_TAB%%resp% `- %Pool%	
			}
			Else
			{
			if (url <> "NA")
			Gui Scan: Add, text, cBlue gCodeGo%A_INDEX%, %Code%`r`n%A_TAB%%resp% `- %Pool%
			else
				Gui Scan: Add, text,, %Code%`r`n%A_TAB%%resp% `- %Pool%
		}
}
		Gui Scan: Add, button, gPodeCodeDestroy, Back to Main



	Gui Scan: Show
	Return


;----------------------;Gui Creation Complete----------------------------

PodeCodeDestroy:
	Gui, destroy
	Gui Scan: Destroy
	Gui COB: Destroy
	Gui 3: Destroy
	gosub declarations
	CreateGUI()
	return
CodeGo1:
url:= ccURL[1]
code:= ccCode[1]
goto newURL
Return
CodeGo2:
url:= ccURL[2]
code:= ccCode[2]
goto newURL
Return
CodeGo3:
url:= ccURL[3]
code:= ccCode[3]
goto newURL
Return
CodeGo4:
url:= ccURL[4]
code:= ccCode[4]
goto newURL
Return
CodeGo5:
url:= ccURL[5]
code:= ccCode[5]
goto newURL
Return
CodeGo6:
url:= ccURL[6]
code:= ccCode[6]
goto newURL
Return
CodeGo7:
url:= ccURL[7]
code:= ccCode[7]
goto newURL
Return
CodeGo8:
url:= ccURL[8]
code:= ccCode[8]
goto newURL
Return
CodeGo9:
url:= ccURL[9]
code:= ccCode[9]
goto newURL
Return
CodeGo10:
url:= ccURL[10]
code:= ccCode[10]
goto newURL
Return
CodeGo11:
url:= ccURL[11]
code:= ccCode[11]
goto newURL
Return
CodeGo12:
url:= ccURL[12]
code:= ccCode[12]
goto newURL
Return
CodeGo13:
url:= ccURL[13]
code:= ccCode[13]
goto newURL
Return
CodeGo14:
url:= ccURL[14]
code:= ccCode[14]
goto newURL
Return
CodeGo15:
url:= ccURL[15]
code:= ccCode[15]
goto newURL
Return
CodeGo16:
url:= ccURL[16]
code:= ccCode[16]
goto newURL
Return
CodeGo17:
url:= ccURL[17]
code:= ccCode[17]
goto newURL
Return
CodeGo18:
url:= ccURL[18]
code:= ccCode[18]
goto newURL
Return
CodeGo19:
url:= ccURL[19]
code:= ccCode[19]
goto newURL
Return
CodeGo20:
url:= ccURL[20]
code:= ccCode[20]
goto newURL
Return

newURL:

StringGetPos, number, code, %A_SPACE%
Stringleft, code, code, %number%
Stringreplace, Code, code, `;,,all
Stringreplace, Code, code, `,,,all
Stringreplace, Code, code, `:,,all


{ ;----------------------;Start NEW URL----------------------------
 For pwb in ComObjCreate("Shell.Application").Windows
{
        urls:= pwb.LocationURL
			Ifinstring, urls, ssl
			{
		ifinstring, urls, .kp.org
		{
			check:= urls
			break
		}
	}
}


if (url <> "NA" AND URL <> "")
{
Wb:= iegetbyURL(check)
StringGetPos, number, Check, .kp.org
number += 7
Stringleft, check, check, %number%

	 For Pwb in ComObjCreate( "Shell.Application" ).Windows
		 If ( Pwb.LocationName <> "" ) && InStr( Pwb.FullName, "iexplore.exe" )
		{
			name:= pwb.LocationName
			ifnotinstring, name, Connection Center
			 winactivate, %name%
		 }

site = %check%%URL%
wb.navigate(site, 2048)
}
}

return

}
;----------------------;END Pend Code Search----------------------------

return

;~ -----------SUBS------------SUBS -----------SUBS---------------------------SUBS------------------SUBS--------------------SUBS------------------------------------

return

ClaimChecks:

gosub Declarations

	Fileread, var, C:\Autohotkey\Tapestry\Program Data\dxCodeList.txt	
for index in iDX	; Determine problem codeds
	if instr(var,"`," . idx[A_INDEX] . ":")
		if (SubStr((subStr(var, 1+(instr(var,"`," . idx[A_INDEX] . ":")))), instr((subStr(var, 1+(instr(var,"`," . idx[A_INDEX] . ":")))),"`:")+1,1) = "T")
			claimAlerts.Push("Transplant")
		else
			claimAlerts.Push("ESRD")
		
	Fileread, var, C:\Autohotkey\Tapestry\Program Data\indProc.txt
for index in iProcedure	; Determine problem procedures
	if instr(var,"`," . iprocedure[A_INDEX] . ":")
		if (SubStr((subStr(var, 1+(instr(var,"`," . iprocedure[A_INDEX] . ":")))), instr((subStr(var, 1+(instr(var,"`," . iprocedure[A_INDEX] . ":")))),"`:")+1,1) = "T")
			claimAlerts.Push("Transplant")
		else
			claimAlerts.Push("ESRD")
		
return

ParseClaim:	; Now with comments
{
claimparsed = YES

;~ gosub Declarations

var:= xClip
masterVar:= Var	; Backup raw text

Stringreplace, var, var,,%A_SPACE%,,all
var:= (StrReplace(var,"`n","`r"))





Ifinstring, Var, 64 Document Control Number
	{	; UB PARSE
	
Claimtype = UB

var:= SubStr(Var,((inStr(var,"UB CLAIM") + StrLen("UB CLAIM #")),n,1))
claimNumber:= ClearSpace(DropLine())		; Claim Number Declared


Stringreplace, var, var,,%A_SPACE%,,all
Stringreplace, var, var, `n,`r,all
StringGetPos, number, var, 3a pat
Stringleft, zip, var, %number%
number = 


for index in stateAbrev
	if insTr(zip,a_Tab . stateAbrev[A_INDEX] . A_TAB)
		zipCode:= (subStr(zip,(insTr(zip,a_Tab . stateAbrev[A_INDEX] . A_TAB)+4),5))




ExtraLines()	; Leading/trailing spaces removed


var:= SubStr(Var,(((inStr(var,"5 Fed Tax No.")-(StrLen("xxx 5 Fed Tax No."))) + StrLen("5 Fed Tax No.")),n,1))

billType:= DropLine()	; Bill Type Declared

var:= SubStr(Var,((inStr(var,"Stmt. To") + StrLen("Stmt. To")),n,1))
var:= SubStr(Var,((inStr(var,"7") + StrLen("7")),n,1))
ExtraLines()			; Leading/trailing spaces removed

Tin:= SubStr(var,1,((inStr(var,A_TAB))-1))	; TIN Declared

var:= SubStr(Var,((inStr(var,A_TAB) + StrLen(A_TAB)),n,1))
fromDate:= SubStr(var,1,((Instr(var,A_Tab,n,1))-1))	; FromDate Declared

var:= SubStr(var,((instr(var,A_TAB,n,1))+1))
toDate:= SubStr(var,1,((Instr(var,A_Tab,n,1))-1))	; ToDate Declared

var:= SubStr(var,((instr(var,"29 acdt",n,1))+1))	; trim up variable
var:= SubStr(var,((instr(var,"30",n,1))+4))

dob:= SubStr(var,1,(instr(var,"`r")-1))	; DOB Declared

sex:= regSpace(SubStr(SubStr(var,((instr(var,"`r",n,1))+1)),1,(instr(SubStr(var,((instr(var,"`r",n,1))+1)),"`r")-1)))	; Sex declared



var:= masterVar	; Reform variable
var:= SubStr(var,((instr(var,"`r",n,1))+1))
Stringreplace, var, var, `n,`r,all
var:= SubStr(var,((instr(var,"`r" . dob,n,1))+1))
; Trim variable back down

loop, parse, var, %A_TAB%	; Entire line is divided by Tabs
{

	if A_INDEX = 8
	dStatus:= regSpace(A_LoopField)	; Get discharge status code
	if (A_INDEX = 9)
		break
}

var:= (SubStr((SubStr((subStr((StrReplace(var,"`r" . A_TAB,"`|")),(Instr((StrReplace(var,"`r" . A_TAB,"`|")),"Non-Covered")))),((instr((subStr((StrReplace(var,"`r" . A_TAB,"`|")),(Instr((StrReplace(var,"`r" . A_TAB,"`|")),"Non-Covered")))),"`r")+1)))),1,(instr((SubStr((subStr((StrReplace(var,"`r" . A_TAB,"`|")),(Instr((StrReplace(var,"`r" . A_TAB,"`|")),"Non-Covered")))),((instr((subStr((StrReplace(var,"`r" . A_TAB,"`|")),(Instr((StrReplace(var,"`r" . A_TAB,"`|")),"Non-Covered")))),"`r")+1)))),"Page")-2)))
; Trim var down


Loop, parse, var, `r	; Parse for the Line Level data
	Loop, Parse, A_LoopField, %A_TAB%
	{
		Category:= slots[A_INDEX]	; RevCode, Description, HCPCS, etc based on the iteration
		item:= A_LoopField
		
		if (category = "iHCPCS")
		{
			if ((StrLen(item)) > 5)	; Modifiers are appended to the end of the 5 digit HCPCS Code, separate them out
			{
				StringTrimLeft, mods, item, 5
				iModi.Push(mods)
				Stringleft, item, item, 5
			}
			else
				iModi.Push("")
		}
		%category%.Push(item)
	}


var:= masterVar	; Redeclare the variable
Stringreplace, var, var, ,%A_SPACE%,all

totalCharges:= (SubStr((SubStr((SubStr(var,((instr(var, "Page" . A_TAB . "1",n,1))+1))),((instr((SubStr(var,((instr(var, "Page" . A_TAB . "1",n,1))+1))), "Totals" . A_TAB,n,1))+7))),1,((Instr((SubStr((SubStr(var,((instr(var, "Page" . A_TAB . "1",n,1))+1))),((instr((SubStr(var,((instr(var, "Page" . A_TAB . "1",n,1))+1))), "Totals" . A_TAB,n,1))+7))),A_TAB,n,1)))-1))	
; Total Billed declared

NPI:= regSpace(SubStr((regSpace(SubStr(var,((instr(var, "Prv ID",n,1))+6)))),1,(Instr((regSpace(SubStr(var,((instr(var, "Prv ID",n,1))+6)))),"`r"))))

; Formatting for DX Parse
var:= (StrReplace((regSpace(SubStr((regSpace(SubStr(var,((instr(var, "66 DX",n,1))+6)))),((instr((regSpace(SubStr(var,((instr(var, "66 DX",n,1))+6)))), "67",n,1))+3)))),"`n","`r"))
if ((SubStr(var,1,1) = A_SPACE) OR (SubStr(var,1,1) = A_TAB) OR (SubStr(var,1,1) = "`r"))
	var:= SubStr(var,1)
dx := StrReplace((SubStr(var,1,((Instr(var,"69 Admit",n,1)))-1)),"`r",A_TAB)
Loop
	ifinstring, dx, %A_TAB%%A_TAB%
		Stringreplace, dx, dx, %A_TAB%%A_TAB%,%A_TAB%,all
	Else
		Break
	
	StringGetPos, number, var,68%A_SPACE%
	Stringleft, dx, var, %number%
	
	dx := regexreplace(dx, "^\s+")	; DX pulled out
	dx := RegExReplace(dx, "\s*$")
	

Loop, parse, dx, %A_TAB%	; DX Codes / POA indicators are divided by tabs now. ODD = DX Even = POA
{
	if ((A_LoopField <> A_SPACE) AND (A_LoopField <> A_TAB))
	{
		if not isEven(A_INDEX)	; If odd number, push to dx
		iDX.Push(A_LoopField)
	Else
		iPOA.Push(A_LoopField)
}
}




var:= masterVar	; Redeclare
Clean(Var)
	GetLF(Var, "74 Prin. Procedure", CUT, Number,Y)
		Trim(Var,Number)
	GetLF(Var, "75 80", CUT, Number,N)
		StringLeft, procV, Var, %Number%
		replacelist = procedure,code,date,other,a.,b.,c.,d.,e.
			loop, parse, replacelist, `,
				Stringreplace, procV, procV, %A_LoopField%,,all
		ProcV := regexreplace(ProcV, "^\s+")
		ProcV := RegExReplace(ProcV, "\s*$")
			Loop, 50
				StringReplace, ProcV, ProcV, %A_SPACE%%A_SPACE%,%A_SPACE%
			Loop, Parse, procV, %A_SPACE%
			{
				if A_LoopField is digit	
				iProcDate.Push(A_LoopField)
			else
				iProcedure.Push(A_LoopField)
			}

	DateFormat(DOB)
		ageDate:= outPutDate ; new var to not overwrite DOB

	DateFormat(fromDate)
		age:= outPutDate ; age declared before calcs as From Date
		age -= ageDate, days	; Subtract to get total age in days
		
	age /= 365				; Convert days to years
	
	
	DateFormat(toDate)
		LOS:= outPutDate 
	DateFormat(fromDate)
		LOS2:= outPutDate
	
	LOS -= los2, days

	StringMid, Btype, BillType, 2,1
		If (BType = 1 OR BTYPE = 2)
			PTYPE = 01
		If (BTYPE = 3)
			PTYPE = 02
	PTYPE += -1

}
 ;----------------------; UB PARSE COMPLETE ;----------------------;; UB PARSE COMPLETE----------------------------------------------------


else
{	; CMS Parse. Much simpler
	
	Stringreplace, var, var,,%A_SPACE%,all
	Stringreplace, var, var, `n,`r,all

	Claimtype = CMS

	ClaimNumber:= SubStr(SubStr(Var,((inStr(var,"#") + StrLen("#")),n,1)),1,(Instr(SubStr(Var,((inStr(var,"#") + StrLen("#")),n,1)),"`r")))


	DOB:= SubStr(RegSpace(SubStr(Var,((inStr(var,"Insured's Date of Birth") + StrLen("Insured's Date of Birth")),n,1))),1,(Instr(RegSpace(SubStr(Var,((inStr(var,"Insured's Date of Birth") + StrLen("Insured's Date of Birth")),n,1))),"`r")))


		Var:= (RegSpace(SubStr(Var,((inStr(var,"sex") + StrLen("sex")),n,1))))
			If (ClearSpace(DropLine()) = "MXF")
				Sex = M
			Else
				Sex = F

	dxList:= StrReplace((StrReplace((StrReplace(SubStr((SubStr(Var,((inStr(var,"ICD Ind") + StrLen("ICD Ind ")),n,1))),((inStr((SubStr(Var,((inStr(var,"ICD Ind") + StrLen("ICD Ind ")),n,1))),"A.") + StrLen("A.")),n,1),((Instr((SubStr(Var,((inStr(var,"ICD Ind") + StrLen("ICD Ind ")),n,1))),"22. R",n,1))-10)),A_SPACE)),"`r",A_TAB)),A_TAB . A_TAB,A_TAB)


			for index in cmsDX
				dxList:= StrReplace(dxList,(cmsDX[A_INDEX]))
	Loop, Parse, dxList,%A_TAB%
		if A_LoopField
			iDX.Push(A_LoopField)


;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ---------------------------------LINE LEVEL SEARCH ------LINE LEVEL SEARCH-------LINE LEVEL SEARCH---------------------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v


		revList:= StrReplace(strReplace((StrReplace(RegSpace(SubStr((SubStr(Var,((inStr(var,"Provider ID #") + StrLen("Provider ID #")),n,1))),1,((Instr((SubStr(Var,((inStr(var,"Provider ID #") + StrLen("Provider ID #")),n,1))),"25. F"))-1))),"`r" . A_TAB,A_TAB)),"`r" . A_TAB,"`r"),"`r`r","`r")


Loop
ifinstring, revList, `r%A_TAB%
Stringreplace, revList, revList, `r%A_TAB%,`r,all
else
	break

Stringreplace, revList, revList, `r`r,|,all
Stringreplace, revList, revList, `r,%A_TAB%,all

Loop, Parse, revList, `|
{
	Iteration:= regSpace(A_LoopField)
	StringGetPos, number, Iteration, /
	number += -2
	StringTrimleft, Iteration, Iteration, %number%
	Loop, parse, Iteration,%A_Tab%
	{
		Element:= regSpace(a_lOOPfIELD)
		slot:= hcpcsSlots[A_INDEX]
		%Slot%.Push(Element)
		if (hcpcsSlots[A_INDEX] = "NPI")
			break
	}
}

StringGetPos, number, var, Federal TAX I
	StringTrimleft, TIN, var, %number%
	

Loop
{
	StringTriMLeft, Temp, TIN, %A_INDEX%
	Stringleft, temp, temp, 1
	if temp is Number
	{
		number:= A_INDEX
		break
	}
}
StringTrimleft, TIN, TIn, %Number%
StringGetPos, number, TIN, %A_SPACE%
Stringleft, tin, tin, %number%

ifinstring, TIN, %A_TAB%
{
	StringGetPos, number, TIN, %A_TAB%
	Stringleft, TIN, TIn, %Number%
}


		TotalCharges:= RegSpace(SubStr((RegSpace(SubStr(Var,((inStr(var,"Total Charge") + StrLen("Total Charge")),n,1)))),1,(Instr((RegSpace(SubStr(Var,((inStr(var,"Total Charge") + StrLen("Total Charge")),n,1)))),A_TAB))))

	DateFormat(DOB)
		ageDate:= outPutDate ; new var to not overwrite DOB
	DateFormat(fromDate)
		age:= outPutDate ; age declared before calcs as From Date
		age -= ageDate, days	; Subtract to get total age in days
	age /= 365	



			Var:= (RegSpace(SubStr(Var,((inStr(var,"Service Facility Location Information") + StrLen("Service Facility Location Information")),n,1))))
			Loop
				if (SubStr(SubStr((RegSpace(SubStr(Var,((inStr(var,"Service Facility Location Information") + StrLen("Service Facility Location Information")),n,1)))),((Instr((RegSpace(SubStr(Var,((inStr(var,"Service Facility Location Information") + StrLen("Service Facility Location Information")),n,1)))),"`rA."))-(A_INDEX+1))),1,1) = A_SPACE)
				{
					zipcode:= SubStr(SubStr((RegSpace(SubStr(Var,((inStr(var,"Service Facility Location Information") + StrLen("Service Facility Location Information")),n,1)))),((Instr((RegSpace(SubStr(Var,((inStr(var,"Service Facility Location Information") + StrLen("Service Facility Location Information")),n,1)))),"`rA."))-(A_INDEX))),1,5)
					break
				}



	
} 

for index in iRev
{
	rev:= irev[A_INDEX]
	hcpcs:= iHCPCS[A_INDEX]
	DOS:= iDOS[A_INDEX]
	Counters:= iCounters[A_INDEX]
	Charges:= iCharges[A_INDEX]
	NonCov:= iNonCov[A_INDEX]
	Modi:= iModi[A_INDEX]


add = `"rev`"`:`"%rev%`"`,`"hcpcs`":`"%hcpcs%`"`,`"dos`":`"%dos%`"`,`"counters`":`"%counters%`"`,`"charges`":`"%charges%`"`,`"modi1`"`:`"%modi1%`"`,`"modi2`"`:`"%modi2%`"`,
clipboard:= add

json = %json%


}

;----------------------; END of CMS Parse----------------------------
return
}
return
;----------------------;END OF Claim Parse SUB----------------------------


ANSIParse:

;----------------------;START ANSI PARSE----------------------------
{
	

Stringreplace, var, var, %A_TAB%,%A_SPACE%,all
Stringreplace, var, var,,%A_SPACE%,all
Stringreplace, var, var, `n,`r,all
	Loop
		ifinstring, var, `r`r
			Stringreplace, var, var, `r`r,`r,all
		else
			break
	Loop
	ifinstring, var, %A_SPACE%%A_SPACE%
		Stringreplace, var, var, %A_SPACE%%A_SPACE%,%A_SPACE%
	else
		Break
	Loop
	ifinstring, var, `r%A_SPACE%
		Stringreplace, var, var, `r%A_SPACE%,`r
	else
		Break

mastervar:= var

	
	ifinstring, var, SV1`*HC
		claimType = CMS
	else
			claimType = UB

	GetLF(Var, "DMG*D8*", CUT, Number, N)
	dob:= subStr(	var,(Number + 8),8)
	sex:= subStr(var,(Number + 17),1)		
	StringLeft, dob, dob, %Number%
		Stringleft, y, dob, 4
		Stringright, d, dob, 2
		StringMid, m, dob, 5, 2
		dob = %M%/%D%/%Y%
		
	var:= masterVar
	StringGetPos, number, var, `-Other Payor
		if (number > 0)
		{
			StringTrimleft, COB, var, %Number%
			StringGetPos, Number, COB, L2400`-Service Line Level
			Stringleft, cob, cob, %number%
			StringGetPos, number, COB, `]
			Number += 1
			StringTrimLeft, cob, cob, %number%
			StringGetPos, number, cob, `~
			Stringleft, cob, cob, %Number%
			Loop, 50
				Stringreplace, cob, cob, `*`*,`*,all
			Loop, parse, cob, `*
			{
				if (A_INDEX = 4)
					ociName:= A_loopField
			}
			StringGetPos, number, var, L2320-Other Coverage Level
			StringTrimLeft, cob, var, %number%
			StringGetPos, number, cob, L2330A`-Other
			Stringleft, cob, cob, %number%
				StringGetPos, number, cob, AMT`*
				StringTrimLeft, cob, cob, %Number%
				StringGetPos, number, Cob, `~
				StringGetPos, tNum, cob, `[
				StringTrimleft, priorportion, cob, %tNum%
				StringLeft, cob, cob, %Number%
				Loop, Parse, COB, `*
				{
					IF (a_index = 3)
						  priorPaid:= A_LoopField
						  ifinstring, A_LoopField, L2320
							Break
				}
				StringGetPos, number, priorportion, `~
				StringLeft, priorportion, priorportion, %Number%
					Loop, Parse, PriorPortion, `*
				{
					IF (a_index = 3)
					priorPatientPortion:= A_LoopField
				}	

		}

if (claimType = "cms")
{

{ ;----------------------;ZIP Lookup Start----------------------------
	StringGetPos, number, var, Service Facility Location
	if (Number > 0)
	{
		StringTrimleft, zip, var, %Number%
		Loop, 2
		{
			StringGetPos, number, zip, `~
			number += 1
			StringTrimLeft, zip, zip, %Number%
		}
		sTRINGgETpOS, number, zip, `~
		StringLeft, zip, zip, %Number%
		Loop
		{
			StringRight, Tem, zip, %A_INDEX%
			ifinstring, tem, `*
			{
				number:= (A_Index - 1)
				Break
			}
		}
		
		StringRight, zip, zip, %Number%
		Stringleft, zip, zip, 5
	}
	
	else
		{
			Loop, 2
			{
				StringGetPos, number, var, -Billing Provider
				StringTrimleft, zip, var, %Number%
			}
			Loop, 2
			{
				StringGetPos, number, zip, `~
				number += 1
				StringTrimLeft, zip, zip, %Number%
			}
			sTRINGgETpOS, number, zip, `~
			StringLeft, zip, zip, %Number%
			Loop
			{
				StringRight, Tem, zip, %A_INDEX%
				ifinstring, tem, `*
				{
					number:= (A_Index - 1)
					Break
				}
			}
			StringRight, zip, zip, %Number%
			Stringleft, zip, zip, 5
		}
			

	var:= masterVar
} 
;----------------------;ZIP Lookup Done----------------------------	
{ ;----------------------;Start Year Lookup----------------------------
	StringGetPos, number, var, L2400-Service Line Level
	StringTrimLeft, date, var, %Number%
	Loop, 2
	{
		StringGetPos, number, date, `~
		number += 1
		StringtrimLeft, date, date, %Number%
	}
	StringGetPos, number, date, `~
	Stringleft, date, date, %Number%

	
	Loop
	{
		StringRight, Tem, Date, %A_INDEX%
		ifinstring, tem, `*
		{
			number:= (A_Index - 1)
			Break
		}
	}
	StringRight, Date, Date, %Number%
	
		Stringleft, year, date, 4
		StringTrimleft, date, date, 4
		Stringleft, month, date, 2
		StringRight, day, date, 2
		
		Date = %Month%/%Day%/%year%
	
	
	
	Loop
	{
		var:= Clipboard
		if (Var = clipboard)
			break
	}

}
Sleep, 500
;----------------------;Year Lookup Done----------------------------
	
{ ;----------------------;CMS Line Level----------------------------	
	Loop
	{
			lineCount = 1
		StringGetPos, number, var, L2400-Service Line Level
		if (number < 0)
			break
		Number += 3
		StringTrimleft, var, var, %Number%
		line:= var
			StringGetPos, number, line, `~
			Number += 1
			StringTriMleft, line, line, %Number%
		
		StringGetPos, number, line, Service
		if (Number > 0)
			StringLeft, line, line, %Number%
		Stringreplace, line, line, `[L2400`],,all
		Stringreplace, line, line, `>, `*,all
		Loop, parse, line, `*
		{
			if (A_INDEX = 3)
				iHCPCS.insertAt(lineCount,A_LoopField)
			if (A_INDEX = 4)
				iModi.insertAt(lineCount,A_LoopField)
			if (A_INDEX >= 5)
			{
				if A_LoopField is DIGIT
				{
					iCharge.insertAt(lineCount,A_LoopField)
					break
				}
			}
			if (A_INDEX = 7)
				iCounter.insertAt(lineCount,A_LoopField)
		}		
			lineCount += 1
	}
}	
;----------------------; END CMS Line Level----------------------------	
}

if (claimType = "UB")
{

{ ;----------------------;BillType Search----------------------------

	StringGetPos, number, var, `>A`> 
	number -= 2
	StringTrimLeft, billType, var, %Number%
	StringGetPos, number, billType, A`>
	number += 3
	StringLeft, billType, billType, %Number%
	Stringreplace, billType, billType, A,,all
	Stringreplace, billType, billType, `>,,all	
	
}

{ ;----------------------;Prior Auth Number Search----------------------------	
	
	ifinstring, var, REF`*G1`*
	{
		GetLF(Var, "REF`*G1`*", CUT, Number, Y)
		StringTrimLeft, priorAuthNum, var, %number%
		StringGetPos, number, priorAuthNum, `~
		Stringleft, priorAuthNum,priorAuthNum,%Number%
		if priorAuthNum is not Number
			priorAuthNum = 
	}
}	
;----------------------;Prior Auth search complete----------------------------	
	
;----------------------;Discharge Status Search----------------------------	
	var:= masterVar
	GetLF(Var, "CL1`*", CUT, Number, n)
		StringTrimleft, dStatus, var, %Number%
		StringGetPos, number, dStatus, `~
				Stringleft, dStatus, dStatus, %number%
			Loop
			{
				StringRight, nh, dStatus, %A_INDEX%
				Stringleft, nh, nh, 1
				if (nh = "`*")
				{
					StringRight, dStatus, dStatus, %A_INDEX%
					StringTrimleft, dStatus, dStatus, 1
					Break
				}
			}
			dStat:= dStatus
;----------------------;Discharge Status Search Complete----------------------------	
	
{ ;----------------------;Find TIN----------------------------
	GetLF(Var, "REF*EI*", CUT, Number, N)
		StringTrimLeft, TIN, var, %NUmber%
		stringGetPos, number, TIN, `~
		StringLeft, tin, tin, %Number%
					Loop
			{
				StringRight, nh, TIN, %A_INDEX%
				Stringleft, nh, nh, 1
				if (nh = "`*")
				{
					StringRight, TIN, TIN, %A_INDEX%
					StringTrimleft, TIN, TIN, 1
					Break
				}
			}
} 
;----------------------;Tin Found----------------------------		

{ ;----------------------;Find NPI----------------------------
		GetLF(Var, "`*`*XX`*", CUT, Number, N)
		StringTrimLeft, NPI, var, %Number%

		StringGetPos, number, npi, `~
		Stringleft, npi, npi, %Number%
		Loop
		{

			ifnotinstring, npi, `*
				break
			StringGetPos, number, NPI, `*

			Number += 1
			StringTrimLeft, npi, npi, %number%
		}
				
}		
;----------------------;NPI Found----------------------------

{ ;----------------------;Find To / From Dates----------------------------
	var:= masterVar
	GetLF(Var, "`*RD8`*", CUT, Number, N)
		number += 5
		StringTrimLeft, dates, var, %Number%
		StringGetPos, number, dates, `~
		Stringleft, dates, dates, %Number%
		StringGetPos, number, dates, `-
	Stringleft, FromDate, dates, %Number%
		number += 1
	StringTriMleft, toDate, dates, %Number%
	ifinstring, fromDate, `*
		Loop
		{
			ifnotinstring, fromDate, `*
				break
			StringGetPos, number, fromDate, *
			number += 1
			StringTrimleft, fromDate, fromDate, %Number%
		}
			Stringleft, y, toDate, 4
			Stringright, d, toDate, 2
			StringRight, y, y, 2
			StringMid, m, toDate, 5, 2
			toDate = %M%%D%%Y%
			Stringleft, y, fromDate, 4
			Stringright, d, fromDate, 2
			StringRight, y, y, 2
			StringMid, m, fromDate, 5, 2
			fromDate = %M%%D%%Y%
	DateFormat(DOB)
		ageDate:= outPutDate		
		DateFormat(fromDate)
		age:= outPutDate ; age declared before calcs as From Date
		age -= ageDate, days	; Subtract to get total age in days
		
	age /= 365	
	
}
;----------------------;To / From Dates Found----------------------------

{ ;----------------------;Find line-level amounts----------------------------
	var:= masterVar
	StringGetPos, number, var, -Service Line Level
	number += 22
	StringTrimleft, var, var, %Number%
	breakSwitch = OFF
		Stringreplace, var, var, `] SV2, `] SV2, UseErrorLevel
		lines:= ErrorLevel
		Stringreplace, var, var, `*`*,`*null`*,all
		lineCountVar = 0
		Loop,
		{
			lineCountVar += 1
			if (breakSwitch = "ON")
				break
			fromLine = LX`*%A_INDEX%`~
			frnL:= StrLen(fromLine)
			StringGetPos, number, var, %fromLine%
				if (number < 0)
					break
				number += %frnL%
				number += 1
				line:= var
					StringTrimleft, line, var, %Number%
				Stringreplace, line, line, `~,`*
				StringGetPos, number, line, `~
				Stringleft, line, line, %Number%
						Stringreplace, line, line, sv2`*,,all
						line:= regexreplace(line, "^\s+")	; Clean it up
						line:= RegExReplace(line, "\s*$")
						stringreplace, line, line, `[L2400`],,all
						stringreplace, line, line, L2400,,all
					
				Loop, Parse, Line, `*
				{
					count:= StrLen(A_LoopField)
					Stringreplace, gec, A_LoopField, HC`>,,
					if (A_INDEX = 1)
						iRev.InsertAt(lineCountVar, A_LoopField)
					If (A_Index = 2)
					{
						ifinstring, gec, `>
							Loop, parse, gec, `>
							{
								if (A_INDEX = 1 AND A_loopField <> "null")
									ihcpcs.InsertAt(lineCountVar, A_LoopField)
								if (A_INDEX = 2)
									iModi.InsertAt(lineCountVar, A_LoopField)
							}
						else
							iHcpcs.InsertAt(lineCountVar, GEC)
					}
				
					if (A_INDEX = 3)
						iCharge.insertAt(lineCountVar, A_LoopFIeld)
					
					if (A_INDEX = 5)
						iCounter.InsertAt(lineCountVar, A_LoopField)
					if (A_INDEX > 5 AND Count = 8)
					{
						if A_LoopFIeld is integer
						{
							Stringleft, y, A_LoopFIeld, 4
							Stringright, d, A_LoopFIeld, 2
							StringRight, y, y, 2
							StringMid, m, A_LoopFIeld, 5, 2
							date = %M%%D%%Y%
							iSDate.InsertAt(lineCountVar, date)
						}
					}
					
				}
				
				
			; Continues to loop to grab next set of line elements	
			
		}
}		
;----------------------;Line level amounts found----------------------------	
	
	var:= masterVar
{ ;----------------------;Start DX Lookup----------------------------
	
	GetLF(Var, "`] HI`*", CUT, Number, Y)
		StringTrimLeft, DX, var, %Number%
		Loop, 100
		Stringreplace, dx, dx, `>`>,`>,,all
		ifinstring, dx, HI`*BBR`>
		{
			StringGetPos, number, dx, HI`*BBR`>	
			Stringleft, dx, dx, %Number%
		}
		StringGetPos, Number, dx, >
		NUmber += 1
		StringTrimLeft, dx, dx, %NUmber%
		StringGetPos, number, dx, `>
		Stringleft, dx1, dx, %Number%
		ifinstring, dx1, `~
		{
			StringGetPos, number, dx1, `~
			StringLeft, dx1, dx1, %Number%
			poa1 = 	
		}
		Else
		{
			Number += 1
			StringTrimLeft, dx, dx, %Number%

			Stringleft, poa1, dx, 1
		}
		
		
		cs = 1
		if (poa1 < 0)
			poa1 = 
		iDX.push(dx1)
		iPoa.push(poa1)
		cs += 1
		ifinstring, dx, HI`*ABF`>
	StringGetPos, number, dx, HI`*ABF`>
	StringTrimleft, dx, dx, %Number%
	Stringreplace, dx, dx, `~,%A_SPACE%,all
	Stringreplace, dx, dx, `*ABF, %A_SPACE%,all
		Stringreplace, dx, dx, HI `>,%A_SPACE%,all
	Stringreplace, dx, dx, `[L2300`],%A_SPACE%,all
	ifinstring, dx, HI`*BE
	StringGetPos, number, dx, HI`*BE
	else
		StringGetPos, number, dx, Attending
		Stringleft, dx, dx, %Number%

	Stringreplace, dx, dx,  HI`*,%A_SPACE%,all
	Stringreplace, dx, dx, `r,%A_SPACE%,all
	Stringreplace, dx, dx, `n,%A_SPACE%,all
	Loop, 300
		Stringreplace, dx, dx, %A_SPACE%%A_SPACE%,%A_SPACE%,,all
	Stringreplace, dx, dx, %A_SPACE%`>,`>,all
	Stringreplace, dx, dx, `>%A_SPACE%,`>,all
	Stringreplace, dx, dx, %A_SPACE%,`>,all
	StringTrimleft, dx, dx, 1
	dx := regexreplace(dx, "^\s+")
	dx := RegExReplace(dx, "\s*$")
	StringRight, xdg, dx, 1
	if (xdg = "`>")
		StringTrimRight, dx,dx,1
	dxFound = NO
		Loop, parse, dx, `>
		{
			ch:= StrLen(A_LoopField)
			if (ch = 1)
			{
				if (DxFound = "YES")
				{
					iPOA.InsertAt(cs, A_LoopField)
					cs += 1
					dxFound = NO
				}
			}
			else
			{
					if (DXFound = "YES")
						{
							ifinstring, A_LoopField, `-
								break
							iPOA.InsertAt(cs, "")
							cs += 1	
							iDX.InsertAt(cs, A_LoopField)
							dxFound = YES
						}
					if (DXFound = "NO")
					{
						
						iDX.InsertAt(cs, A_LoopField)
						dxFound = YES
					}

			}
			
		}
		

		
}
;----------------------;DX Lookup Complete----------------------------
	
{ ;----------------------;Start Proc Search----------------------------	
	ifinstring, var, HI*BBR
	{
		GetLF(Var, "HI`*BBR", CUT, Number, Y)
			StringTrimLeft, proc, var, %Number%
			StringGetPos, number, proc, HI*BH>
			Stringleft, proc, proc, %number%
			Stringreplace, proc, proc, `[L2300`],,all
			Stringreplace, proc, proc, `*BBQ,,all
			Stringreplace, proc, proc, Hi`>,`>,all
			Stringreplace, proc, proc, d8`>,,all
			Stringreplace, proc, proc, `r,,all
			Stringreplace, proc, proc, `n,,all
			stringreplace, proc, proc, `~,,all
			Stringreplace, proc, proc, %A_SPACE%,,all5
			Stringtrimleft, proc, proc, 1
			ifinstring, proc, `*
			{
				StringGetPos, number, proc, `*
				Number += 1
				StringTrimLeft, proc, proc, %Number%
			}
			ifinstring, proc, BBR`>
			{
				StringGetPos, number, proc, BBR`>
				Number += 4
				StringTrimLeft, proc, proc, %Number%
			}
			
				Loop, parse, proc, `>
				{
					if A_LoopField is integer
					{
						if (A_loopFIeld > 0)
					{
							Stringleft, y, A_LoopFIeld, 4
							Stringright, d, A_LoopFIeld, 2
							StringRight, y, y, 2
							StringMid, m, A_LoopFIeld, 5, 2
							date = %M%%D%%Y%
						iProcDate.Push(date)
					}
					}
					else
					if (A_loopField > 0)
						iProcedure.Push(A_LoopField)
					
				}

		}
}
;----------------------;Proc Search Complete----------------------------


	DateFormat(toDate)
		LOS:= outPutDate ; new var to not overwrite DOB
	DateFormat(fromDate)
		LOS2:= outPutDate ; new var to not overwrite DOB
	
	LOS -= los2, days

	StringMid, Btype, BillType, 2,1
		If (BType = 1 OR BTYPE = 2)
			PTYPE = 01
		If (BTYPE = 3)
			PTYPE = 02
	PTYPE += -1

	
}
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ----------UB SEARCH COMPLETE-----UB SEARCH COMPLETE------UB SEARCH COMPLETE-------UB SEARCH COMPLETE-------UB SEARCH COMPLETE------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
	
return	

}


return








;AD01

Declarations:
{ ;Declarations - Also serves to empty out variables
	
Global StateAbrev:= ["AL","AK","AZ","AR","CA","CO","CT","DE","FL","GA","HI","ID","IL","IN","IA","KS","KY","LA","ME","MD","MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK","OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY","GU","PR","VI"]
Global ascDates:= ["20160101016","20160401016","20160701016","20161001016","20170101017","20170401017","20170701017","20171001017"]
Global cmsDX := ["b.","c.","d.","e.","f.","g.","h.","i.","j.","k.","l."]
Global abList:= ["C","G","h","m","n","o","s","v","w"]		
Global decr:= ["Colorado","Georgia","Hawaii","Mid-Atlantic","NCAL","Oregon","SCAL","Virginia","Washington"]	
Global slots:= ["iRev", "iDesc", "iHCPCS", "iDOS", "iCounters", "iCharges", "iNonCov"]		
Global hcpcsSlots:= ["ifromDate", "itoDate", "iPOS","BlankSpace","BlankSpace","iHCPCS", "iModi","iDXPointer","iCharges","iCounters","iFamilyPLan","NPITEXT","iNPI"]	
Global asw:=A_ScreenWidth
Global ash:=A_ScreenHeight
Global Y:="YES"
Global N:="No"
Global claimParsed:="NO"
Global COB:="NO"
Global ascBlanks:=0

global ascPrice:=[]
global ascHCPCS:=[]
global fromDate:=[]
Global claimAlerts:=[]
global ccNumber:=[]
global ccCode:=[]
global ccPool:=[]
global ccResp:=[]
global ccURL:=[]
global masterCompare:=[]
global masterListicle:=[]
GLobal claimLevel:=[]
Global iSDATE:=[]
GLobal iPOA:=[]
Global iProcedure:=[]
Global iProcDate:=[]
Global iDX:=[]
Global iModi:=[]
Global iCharge:=[]
Global iFromDate:=[]
Global iPOS:=[]
Global iLine:=[]
Global iRev:=[]
Global iDOS:=[]
Global iDesc:=[]
Global iHCPCS:=[]
Global iCharges:=[]
Global hcpcsneueListe:=[]
Global reColor:=[]
Global priceList:=[]
Global globASC:=[]
Global phCodes:=[]


global zipCode:=
Global x:=
global searchVarX:=
global searchVarY:=
Global file:=
global file1:=
global backColor:=
global pBitmapFile1:=
global Width:=
global height:=
global color:=
global xCor:=
global yCor:=
global savetofil:=
Global colorBackup:=
global newColor:=
global totalCalc:=
global totalVarCalculated:=
global numList:=
Global ociName:=
Global priorPaid:=
Global priorPatientPortion:=
Global claimNumber:=
global ASCPriceType1:=
global ASCPriceType2:=
global ASCPriceType3:=
Global HCPCSASCp1:=
Global HCPCSASCp2:=
Global HCPCSASCp3:=
Global HCPCSASC1:=
Global HCPCSASC2:=
Global HCPCSASC3:=
Global text:=
Global Check:=
Global unterBrecher:=
global Pass:=
global Calc:=
global Calcs:=
Global number:=
Global Ptype:=
Global dStatus:=
Global Style:=
global nav:=
global theme:=
Global xClip:=
Global cut:=
Global type:=
Global masterVar:=
Global outputDate:=
Global Billtype:=
Global priorAuthNum:=
Global TIN:=
Global toDate:=
Global dob:=
Global sex:=
Global dStat:=
Global ClaimType:=
Global totalCharges:=
Global npi:=
Global Age:=
Global LOS:=
Global ZIP:=
Global errorChecking:=
global brecher:=
global Percentage:=
Global Master:=
Global masterList:=
Global Sort:=
Global maxLength:=
Global pgNum:=
Global var:=
Global ocrX :=
Global ocrY :=
Global ocrW :=
Global ocrH :=
Global FileName:= 
return
}
;----------------------; End Declarations----------------------------


	
^J::
Go3:
Reload
return
Go4:
Reload
return
Go5:
Exitapp




;AI01



Installs() {	; 
	
FileCreateDir, C:\AutoHotkey
FileCreateDir, C:\AutoHotkey\Tapestry
FileCreateDir, C:\AutoHotkey\Tapestry\Altitude
FileCreateDir, C:\AutoHotkey\Tapestry\Altitude\Navigation

FileCreateDir, C:\AutoHotkey\Tapestry\DeepBlue
FileCreateDir, C:\AutoHotkey\Tapestry\DeepBlue\Navigation

FileCreateDir, C:\AutoHotkey\Tapestry\Verdant
FileCreateDir, C:\AutoHotkey\Tapestry\Verdant\Navigation

FileCreateDir, C:\AutoHotkey\Tapestry\Lavender
FileCreateDir, C:\AutoHotkey\Tapestry\Lavender\Navigation

FileCreateDir, C:\AutoHotkey\Tapestry\Contrast
FileCreateDir, C:\AutoHotkey\Tapestry\Contrast\Navigation

FileCreateDir, C:\Autohotkey\Tapestry\Generic
FileCreateDir, C:\Autohotkey\Tapestry\Generic\Navigation
	


ifnotexist, C:\AutoHotkey\Tapestry\Program Data\allcodes.txt
Msgbox, File not found - C:\AutoHotkey\Tapestry\Program Data\allcodes.txt, C:\AutoHotkey\Tapestry\Program Data\allcodes.txt
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\accountsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\accountsDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\accountsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\accountsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\accountsUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\accountsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\adjOptionsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\adjOptionsDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\adjOptionsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\adjOptionsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\adjOptionsUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\adjOptionsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\adjReviewDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\adjReviewDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\adjReviewDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\adjReviewUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\adjReviewUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\adjReviewUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\ansiDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\ansiDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\ansiDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\ansiUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\ansiUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\ansiUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\basicInfoDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\basicInfoDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\basicInfoDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\basicInfoUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\basicInfoUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\basicInfoUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\codeEditDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\codeEditDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\codeEditDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\codeEditUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\codeEditUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\codeEditUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\crmDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\crmDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\crmDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\crmUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\crmUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\crmUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\dxDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\dxDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\dxDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\dxUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\dxUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\dxUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\exportsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\exportsDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\exportsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\exportsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\exportsUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\exportsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\historyDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\historyDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\historyDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\historyUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\historyUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\historyUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\miscDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\miscDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\miscDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\miscUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\miscUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\miscUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\notesDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\notesDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\notesDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\notesUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\notesUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\notesUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\onlyOne.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\onlyOne.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\onlyOne.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\paperForm.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\paperForm.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\paperForm.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\paperFormLocked.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\paperFormLocked.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\paperFormLocked.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\scansDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\scansDown.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\scansDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Altitude\Navigation\scansUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Altitude\Navigation\scansUp.BMP,C:\Autohotkey\Tapestry\Altitude\Navigation\scansUp.BMP

ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\accountsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\accountsDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\accountsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\accountsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\accountsUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\accountsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\adjOptionsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\adjOptionsDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\adjOptionsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\adjOptionsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\adjOptionsUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\adjOptionsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\adjReviewDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\adjReviewDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\adjReviewDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\adjReviewUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\adjReviewUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\adjReviewUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\ansiDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\ansiDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\ansiDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\ansiUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\ansiUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\ansiUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\basicInfoDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\basicInfoDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\basicInfoDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\basicInfoUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\basicInfoUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\basicInfoUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\codeEditDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\codeEditDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\codeEditDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\codeEditUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\codeEditUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\codeEditUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\crmDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\crmDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\crmDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\crmUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\crmUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\crmUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\dxDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\dxDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\dxDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\dxUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\dxUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\dxUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\exportsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\exportsDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\exportsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\exportsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\exportsUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\exportsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\historyDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\historyDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\historyDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\historyUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\historyUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\historyUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\miscDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\miscDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\miscDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\miscUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\miscUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\miscUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\notesDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\notesDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\notesDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\notesUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\notesUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\notesUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\paperForm.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\paperForm.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\paperForm.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\paperFormLocked.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\paperFormLocked.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\paperFormLocked.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\scansDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\scansDown.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\scansDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Contrast\Navigation\scansUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Contrast\Navigation\scansUp.BMP,C:\Autohotkey\Tapestry\Contrast\Navigation\scansUp.BMP

ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\accountsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\accountsDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\accountsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\accountsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\accountsUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\accountsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjOptionsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjOptionsDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjOptionsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjOptionsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjOptionsUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjOptionsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjReviewDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjReviewDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjReviewDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjReviewUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjReviewUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\adjReviewUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\ansiDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\ansiDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\ansiDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\ansiUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\ansiUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\ansiUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\basicInfoDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\basicInfoDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\basicInfoDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\basicInfoUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\basicInfoUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\basicInfoUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\codeEditDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\codeEditDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\codeEditDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\codeEditUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\codeEditUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\codeEditUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\crmDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\crmDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\crmDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\crmUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\crmUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\crmUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\dxDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\dxDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\dxDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\dxUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\dxUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\dxUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\exportsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\exportsDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\exportsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\exportsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\exportsUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\exportsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\historyDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\historyDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\historyDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\historyUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\historyUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\historyUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\miscDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\miscDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\miscDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\miscUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\miscUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\miscUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\notesDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\notesDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\notesDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\notesUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\notesUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\notesUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\paperForm.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\paperForm.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\paperForm.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\paperFormLocked.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\paperFormLocked.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\paperFormLocked.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\scansDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\scansDown.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\scansDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\DeepBlue\Navigation\scansUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\DeepBlue\Navigation\scansUp.BMP,C:\Autohotkey\Tapestry\DeepBlue\Navigation\scansUp.BMP

ifnotexist, C:\Autohotkey\Tapestry\Generic\Navigation\copyMRN.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\Navigation\copyMRN.BMP,C:\Autohotkey\Tapestry\Generic\Navigation\copyMRN.BMP

ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\accounts.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\accounts.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\accounts.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\accountsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\accountsDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\accountsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\adjOptionsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\adjOptionsDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\adjOptionsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\adjOptionsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\adjOptionsUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\adjOptionsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\adjReviewDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\adjReviewDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\adjReviewDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\adjReviewUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\adjReviewUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\adjReviewUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\ansiDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\ansiDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\ansiDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\ansiUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\ansiUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\ansiUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\basicInfoDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\basicInfoDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\basicInfoDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\basicInfoUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\basicInfoUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\basicInfoUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\codeEditDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\codeEditDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\codeEditDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\codeEditUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\codeEditUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\codeEditUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\crmDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\crmDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\crmDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\crmUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\crmUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\crmUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\dxDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\dxDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\dxDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\dxUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\dxUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\dxUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\exportsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\exportsDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\exportsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\exportsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\exportsUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\exportsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\historyDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\historyDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\historyDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\historyUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\historyUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\historyUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\miscDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\miscDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\miscDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\miscUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\miscUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\miscUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\notesDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\notesDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\notesDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\notesUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\notesUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\notesUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\paperForm.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\paperForm.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\paperForm.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\paperFormLocked.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\paperFormLocked.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\paperFormLocked.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\scansDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\scansDown.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\scansDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Lavender\Navigation\scansUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Lavender\Navigation\scansUp.BMP,C:\Autohotkey\Tapestry\Lavender\Navigation\scansUp.BMP




ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\accountsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\accountsDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\accountsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\accountsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\accountsUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\accountsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\adjOptionsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\adjOptionsDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\adjOptionsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\AdjOptionsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\AdjOptionsUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\AdjOptionsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\adjReviewDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\adjReviewDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\adjReviewDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\adjReviewUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\adjReviewUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\adjReviewUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\ansiDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\ansiDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\ansiDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\ansiUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\ansiUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\ansiUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\basicInfoDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\basicInfoDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\basicInfoDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\basicInfoUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\basicInfoUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\basicInfoUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\codeEditDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\codeEditDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\codeEditDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\codeEditUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\codeEditUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\codeEditUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\crmDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\crmDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\crmDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\crmUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\crmUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\crmUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\dxDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\dxDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\dxDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\dxUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\dxUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\dxUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\exportsDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\exportsDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\exportsDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\exportsUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\exportsUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\exportsUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\historyDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\historyDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\historyDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\historyUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\historyUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\historyUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\miscDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\miscDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\miscDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\miscUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\miscUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\miscUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\notesDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\notesDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\notesDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\notesUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\notesUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\notesUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\paperForm.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\paperForm.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\paperForm.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\paperFormLocked.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\paperFormLocked.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\paperFormLocked.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\scansDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\scansDown.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\scansDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Verdant\Navigation\scansUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Verdant\Navigation\scansUp.BMP,C:\Autohotkey\Tapestry\Verdant\Navigation\scansUp.BMP

ifnotexist, C:\Autohotkey\Tapestry\Generic\adjCopy.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\adjCopy.BMP,C:\Autohotkey\Tapestry\Generic\adjCopy.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\adjCT.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\adjCT.BMP,C:\Autohotkey\Tapestry\Generic\adjCT.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\adjReviewCopy.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\adjReviewCopy.BMP,C:\Autohotkey\Tapestry\Generic\adjReviewCopy.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\allOptions.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\allOptions.bmp,C:\Autohotkey\Tapestry\Generic\allOptions.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\arrow.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\arrow.bmp,C:\Autohotkey\Tapestry\Generic\arrow.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\attach.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\attach.BMP,C:\Autohotkey\Tapestry\Generic\attach.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\attending.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\attending.BMP,C:\Autohotkey\Tapestry\Generic\attending.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\aType.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\aType.bmp,C:\Autohotkey\Tapestry\Generic\aType.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\billingProv.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\billingProv.BMP,C:\Autohotkey\Tapestry\Generic\billingProv.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\bldAmt.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\bldAmt.bmp,C:\Autohotkey\Tapestry\Generic\bldAmt.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\blueBlip.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\blueBlip.BMP,C:\Autohotkey\Tapestry\Generic\blueBlip.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\cap.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\cap.bmp,C:\Autohotkey\Tapestry\Generic\cap.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\cca.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\cca.BMP,C:\Autohotkey\Tapestry\Generic\cca.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\clkDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\clkDown.BMP,C:\Autohotkey\Tapestry\Generic\clkDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\clkLeft.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\clkLeft.BMP,C:\Autohotkey\Tapestry\Generic\clkLeft.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\clkRight.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\clkRight.BMP,C:\Autohotkey\Tapestry\Generic\clkRight.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\clkUp.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\clkUp.BMP,C:\Autohotkey\Tapestry\Generic\clkUp.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\CloseService.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\CloseService.BMP,C:\Autohotkey\Tapestry\Generic\CloseService.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\cmsForm.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\cmsForm.BMP,C:\Autohotkey\Tapestry\Generic\cmsForm.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\cmsFormSelected.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\cmsFormSelected.BMP,C:\Autohotkey\Tapestry\Generic\cmsFormSelected.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\completed.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\completed.bmp,C:\Autohotkey\Tapestry\Generic\completed.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\Coppers.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\Coppers.BMP,C:\Autohotkey\Tapestry\Generic\Coppers.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\CopyA.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\CopyA.BMP,C:\Autohotkey\Tapestry\Generic\CopyA.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\Copyg.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\Copyg.bmp,C:\Autohotkey\Tapestry\Generic\Copyg.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\copyMRN.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\copyMRN.BMP,C:\Autohotkey\Tapestry\Generic\copyMRN.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\CRM.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\CRM.BMP,C:\Autohotkey\Tapestry\Generic\CRM.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\crmNo.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\crmNo.BMP,C:\Autohotkey\Tapestry\Generic\crmNo.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\crmResolved.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\crmResolved.bmp,C:\Autohotkey\Tapestry\Generic\crmResolved.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\crmUnresolved.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\crmUnresolved.bmp,C:\Autohotkey\Tapestry\Generic\crmUnresolved.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\dBlip.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\dBlip.BMP,C:\Autohotkey\Tapestry\Generic\dBlip.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\dob.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\dob.bmp,C:\Autohotkey\Tapestry\Generic\dob.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\drg.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\drg.BMP,C:\Autohotkey\Tapestry\Generic\drg.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\elImage.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\elImage.BMP,C:\Autohotkey\Tapestry\Generic\elImage.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\extraBox.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\extraBox.BMP,C:\Autohotkey\Tapestry\Generic\extraBox.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\fromCCA.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\fromCCA.BMP,C:\Autohotkey\Tapestry\Generic\fromCCA.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\inBasket.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\inBasket.BMP,C:\Autohotkey\Tapestry\Generic\inBasket.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\inProgress.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\inProgress.BMP,C:\Autohotkey\Tapestry\Generic\inProgress.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\lineBreak.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\lineBreak.BMP,C:\Autohotkey\Tapestry\Generic\lineBreak.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\mainCopy.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\mainCopy.bmp,C:\Autohotkey\Tapestry\Generic\mainCopy.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\mainWarn.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\mainWarn.BMP,C:\Autohotkey\Tapestry\Generic\mainWarn.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\manualRoute.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\manualRoute.BMP,C:\Autohotkey\Tapestry\Generic\manualRoute.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\menu.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\menu.bmp,C:\Autohotkey\Tapestry\Generic\menu.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\nCap.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\nCap.bmp,C:\Autohotkey\Tapestry\Generic\nCap.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\next.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\next.BMP,C:\Autohotkey\Tapestry\Generic\next.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\nextDown.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\nextDown.bmp,C:\Autohotkey\Tapestry\Generic\nextDown.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\nextSel.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\nextSel.bmp,C:\Autohotkey\Tapestry\Generic\nextSel.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\noNext.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\noNext.bmp,C:\Autohotkey\Tapestry\Generic\noNext.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\noRef.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\noRef.BMP,C:\Autohotkey\Tapestry\Generic\noRef.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\note.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\note.BMP,C:\Autohotkey\Tapestry\Generic\note.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\other.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\other.bmp,C:\Autohotkey\Tapestry\Generic\other.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\outgoing.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\outgoing.bmp,C:\Autohotkey\Tapestry\Generic\outgoing.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\outGoingDown.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\outGoingDown.BMP,C:\Autohotkey\Tapestry\Generic\outGoingDown.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\patBlank.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\patBlank.bmp,C:\Autohotkey\Tapestry\Generic\patBlank.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\progress.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\progress.bmp,C:\Autohotkey\Tapestry\Generic\progress.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\refLook.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\refLook.BMP,C:\Autohotkey\Tapestry\Generic\refLook.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\req.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\req.bmp,C:\Autohotkey\Tapestry\Generic\req.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\serviceCopy.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\serviceCopy.BMP,C:\Autohotkey\Tapestry\Generic\serviceCopy.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\sldBlue.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\sldBlue.BMP,C:\Autohotkey\Tapestry\Generic\sldBlue.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\sType.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\sType.BMP,C:\Autohotkey\Tapestry\Generic\sType.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\svcAM.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\svcAM.BMP,C:\Autohotkey\Tapestry\Generic\svcAM.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\textEnter.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\textEnter.BMP,C:\Autohotkey\Tapestry\Generic\textEnter.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\totalAlt.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\totalAlt.bmp,C:\Autohotkey\Tapestry\Generic\totalAlt.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\totalAlt2.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\totalAlt2.bmp,C:\Autohotkey\Tapestry\Generic\totalAlt2.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\totals2.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\totals2.BMP,C:\Autohotkey\Tapestry\Generic\totals2.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\totals2.png
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\totals2.png,C:\Autohotkey\Tapestry\Generic\totals2.png
ifnotexist, C:\Autohotkey\Tapestry\Generic\TOTALStart.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\TOTALStart.bmp,C:\Autohotkey\Tapestry\Generic\TOTALStart.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\ubForm.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\ubForm.BMP,C:\Autohotkey\Tapestry\Generic\ubForm.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\ubFormSelected.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\ubFormSelected.BMP,C:\Autohotkey\Tapestry\Generic\ubFormSelected.BMP
ifnotexist, C:\Autohotkey\Tapestry\Generic\voidCRM.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\voidCRM.bmp,C:\Autohotkey\Tapestry\Generic\voidCRM.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\wait.bmp
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\wait.bmp,C:\Autohotkey\Tapestry\Generic\wait.bmp
ifnotexist, C:\Autohotkey\Tapestry\Generic\zeros.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\zeros.BMP,C:\Autohotkey\Tapestry\Generic\zeros.BMP

ifnotexist, C:\Autohotkey\Tapestry\Generic\Navigation\copyMRN.BMP
Msgbox, File not found - C:\Autohotkey\Tapestry\Generic\Navigation\copyMRN.BMP,C:\Autohotkey\Tapestry\Generic\Navigation\copyMRN.BMP



ifnotexist, C:\Autohotkey\Tapestry\Program Data\allcodes.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\allcodes.txt,C:\Autohotkey\Tapestry\Program Data\allcodes.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\asc2016.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\asc2016.txt,C:\Autohotkey\Tapestry\Program Data\asc2016.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\asc2016Rates.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\asc2016Rates.txt,C:\Autohotkey\Tapestry\Program Data\asc2016Rates.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\asc2017.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\asc2017.txt,C:\Autohotkey\Tapestry\Program Data\asc2017.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\asc2017Rates.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\asc2017Rates.txt,C:\Autohotkey\Tapestry\Program Data\asc2017Rates.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\ASCGroups.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\ASCGroups.txt,C:\Autohotkey\Tapestry\Program Data\ASCGroups.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\codesData.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\codesData.txt,C:\Autohotkey\Tapestry\Program Data\codesData.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\dxCodeList.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\dxCodeList.txt,C:\Autohotkey\Tapestry\Program Data\dxCodeList.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\gears.gif
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\gears.gif,C:\Autohotkey\Tapestry\Program Data\gears.gif
ifnotexist, C:\Autohotkey\Tapestry\Program Data\genericstatezips.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\genericstatezips.txt,C:\Autohotkey\Tapestry\Program Data\genericstatezips.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\genericstatezipss.ird
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\genericstatezipss.ird,C:\Autohotkey\Tapestry\Program Data\genericstatezipss.ird
ifnotexist, C:\Autohotkey\Tapestry\Program Data\indProc.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\indProc.txt,C:\Autohotkey\Tapestry\Program Data\indProc.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\inout.txt
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\inout.txt,C:\Autohotkey\Tapestry\Program Data\inout.txt
ifnotexist, C:\Autohotkey\Tapestry\Program Data\Tapestry Question Log - Copy.accdb
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\Tapestry Question Log - Copy.accdb,C:\Autohotkey\Tapestry\Program Data\Tapestry Question Log - Copy.accdb
ifnotexist, C:\Autohotkey\Tapestry\Program Data\Tapestry Toolset.EXE
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\Tapestry Toolset WBETA.EXE,C:\Autohotkey\Tapestry\Program Data\Tapestry Toolset.EXE


ifnotexist, C:\Autohotkey\Tapestry\Program Data\ToolWatch.ahk
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\ToolWatch.ahk,C:\Autohotkey\Tapestry\Program Data\ToolWatch.ahk
ifnotexist, C:\Autohotkey\Tapestry\Program Data\ToolWatch.exe
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\ToolWatch.exe,C:\Autohotkey\Tapestry\Program Data\ToolWatch.exe
ifnotexist, C:\Autohotkey\Tapestry\Program Data\untitled.png
Msgbox, File not found - C:\Autohotkey\Tapestry\Program Data\untitled.png,C:\Autohotkey\Tapestry\Program Data\untitled.png


return
}






;AR01
ReColor:

File:= reColor[1]
backColor:= reColor[2]	; This sub should be a function, but it doesn't like that for some reason
xCor:= reColor[3]
yCor:= reColor[4]


PixelGetColor, color, %xCor%, %yCor%, slow, rgb		; Get background pixel color

colorBackup:= color
StringTrimleft, color, color, 2
newColor = 0xff%color%	; Make it usable

backColor = 0xFF%backColor%	; Make it usable

ifinstring, file, .bmp.bmp
	Stringreplace, file, file, .bmp,,all	; Clean up file


File1 = C:\AutoHotkey\Tapestry\Generic\%file%.bmp	; Source file

If !pToken := Gdip_Startup()
{
	MsgBox, 48, Error!, Image edit failed.
	ExitApp
}

pBitmapFile1 := Gdip_CreateBitmapFromFile(File1)
Width := Gdip_GetImageWidth(pBitmapFile1), Height := Gdip_GetImageHeight(pBitmapFile1)	; Get source file dimensions
x=0
y=0
loop %width%
{

loop %height%
  {
  color:=Gdip_GetPixel(pBitmapFile1, x, y)	; Get each individual pixel color
  if (color = backcolor)
  Gdip_SetPixel(pBitmapFile1, x, y, newcolor)	; if the pixel is a specified 'green screen' color, modify it to the new color found from the background

  y++
  }
x++
y=0
}
savetofil =  C:\AutoHotkey\Tapestry\Generic\%file%END.bmp	; Save as a new file
Gdip_SaveBitmapToFile(pBitmapFile1, savetofil)
Gdip_DisposeImage(pBitmapFile1)
Gdip_DeleteGraphics(G)
Gdip_Shutdown(pToken)
Sleep, 0

reColor:= {}	; Clear

return



























	

;AF01
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
; ------------------FUNCTIONS------------------FUNCTIONS----------------------FUNCTIONS------------------FUNCTIONS-------------------
;^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v


{ ; Functions
Memory_Compare(mem1,mem2,len:=0){
	return VarSetCapacity(mem2)=DllCall("ntdll\RtlCompareMemory","PTR",&mem1,"PTR",&mem2,"PTR",len?len:VarSetCapacity(mem2))	; Not super useful
}

checkSame(File1, File2){	; Same as above	
	If !pToken := Gdip_Startup()
	{
		MsgBox, 48, Error!, Image edit failed.
		ExitApp
	}
	
	pBitmapFile1 := Gdip_CreateBitmapFromFile(File1)
	pBitmapFile2 := Gdip_CreateBitmapFromFile(File2)
	Width := Gdip_GetImageWidth(pBitmapFile1), Height := Gdip_GetImageHeight(pBitmapFile1)
	processed = 0
	x=0
	y=0
	res = 1
	loop %width%
	{
		loop %height%
		{
			color:= color . A_SPACE . Gdip_GetPixel(pBitmapFile1, x, y)
			color2:= color2 . A_SPACE . Gdip_GetPixel(pBitmapFile1, x, y)
			y++
			if (color2 <> color)
			{
				res = 0
				break
			}
		}
		
		x++
		y=0
	}
	
	color = 
	color2 = 
	
	
	Gdip_DisposeImage(pBitmapFile1)
	Gdip_DeleteGraphics(G)
	Gdip_Shutdown(pToken)
	Gdip_DisposeImage(pBitmapFile2)
	Gdip_DeleteGraphics(G)
	Gdip_Shutdown(pToken)
	Sleep, 0
	return res
}

checkprocessed(File1){			; Returns whether image has black pixel text 0/1
If !pToken := Gdip_Startup()
{
	MsgBox, 48, Error!, Image edit failed.
	ExitApp
}
pBitmapFile1 := Gdip_CreateBitmapFromFile(File1)
Width := Gdip_GetImageWidth(pBitmapFile1), Height := Gdip_GetImageHeight(pBitmapFile1)
processed = 0
x=0
y=0
loop %width%
{
loop %height%
  {
  color:=Gdip_GetPixel(pBitmapFile1, x, y)
  if (color <> Color2)
  color2:=Gdip_GetPixel(pBitmapFile1, x, y)
  
  if color
  if (color = 0xFF000000)	; Text identified
	{
		processed = 1
		break
	}
  y++
  }
x++
y=0
}
Gdip_DisposeImage(pBitmapFile1)
Gdip_DisposeImage(FIle1)
Gdip_DeleteGraphics(G)
Gdip_Shutdown(pToken)
Sleep, 0
return processed
}

Screenshot(x,y,w,h, OutputFilePath, hwnd="") {
			
			pBitmap:= 
			pToken:= 
			pBitmap2:= 
			G2:= 
			pToken:= 
			
			If !pToken := Gdip_Startup()
			{
				MsgBox, 48, Error!, Image edit failed.
				ExitApp
			}
	
			hwnd := (hwnd="") ? WinExist("A") : hwnd ; active or specified window
			pBitmap := Gdip_BitmapFromHWND(hwnd)
			if (pBitmap < 1)
			pToken := Gdip_Startup(), pBitmap := Gdip_BitmapFromHWND(hwnd)
			pBitmap2 := Gdip_CreateBitmap(w, h)	; Dimensions given
			G2 := Gdip_GraphicsFromImage(pBitmap2), Gdip_SetSmoothingMode(G2, 4), Gdip_SetInterpolationMode(G2, 7)
			Gdip_DrawImage(G2, pBitmap, 0, 0, w, h, x, y, w, h)	; Map image section to new image
			Gdip_SaveBitmapToFile(pBitmap2, OutputFilePath)	; Save as file name given
			Gdip_DisposeImage(pBitmapFile1)
			Gdip_DeleteGraphics(G)
			Gdip_Shutdown(pToken)
			Gdip_DeleteGraphics(G2), Gdip_DisposeImage(pBitmap), Gdip_DisposeImage(pBitmap2)
	return
			}			
			
regSpace(element) {
element := regexreplace(element, "^\s+")
element := RegExReplace(element, "\s*$")
return element
}
DropLine() {
	repVar:= var
	StringGetPos, number, repVar, `r
	Stringleft, repVar, repVar, %number%
return repVar
}
clearSpace(repVar) {
Stringreplace, repVar, repVar, %A_SPACE%,,all
Stringreplace, repVar, repVar, %A_TAB%,,all
return repVar
}
extraLines() {
Loop
{
	Stringreplace, var, var, `r`r,`r,all
	Stringreplace, var, var, `r%A_TAB%,`r,all
	Stringreplace, var, var, `r%A_SPACE%,`r,all
	Ifnotinstring, var, `r`r
		ifnotinstring, var, `r%A_TAB%
			Ifnotinstring, var, `r%A_SPACE%
			break
	}
	var := regexreplace(var, "^\s+")
	var := RegExReplace(var, "\s*$")
	return
}
isEven(number) {
if (SubStr((Round((number / 2),1)),Instr(Round((number/ 2),1),".",n,1)+1) = 0)
	return True
Else
	return False
}
ascCancel(Reason) {
					Gui 3: Show
					Winminimize, Tapestry Toolset
					Msgbox Please enter a %reason%			; Error handling
					Winrestore, Tapestry Toolset
					return
}
GenSearch(searchVarX,searchVarY,searchMaxX,searchMaxY,file){

ifinstring, file, .bmp
	Stringreplace, file, file, .bmp,,all
file = C:\Autohotkey\Tapestry\Generic\%file%.bmp

Loop
{
	ImageSearch, X, Y, %searchVarX%, %searchVarY%, %searchMaxX%, %searchMaxY%, %file%
	if errorlevel = 0
		break
}
return
}
Findspace(byref Number, byref var){
	StringGetPos, Number, Var, %A_SPACE%
	return
}
GetLF(byRef Var,byRef LF,byRef Cut,byRef Number, YORN){
	StringGetPos, Number, Var, %LF%

	Cut:= StrLen(LF)
		if (YORN = "yes")	; Pass a Y to add in the Strlength of the search term
		{
			Number += %CUT%
		}
		If YORN IS digit
		Number += -YORN	; Pass a number to add the number instead. Or N to add nothing
return
}
Trim(byref Var, byRef Number){
	StringTrimLeft, Var, Var, %Number%
	Var := regexreplace(Var, "^\s+")	; Remove leading whitespace
	Loop, 300
		Stringreplace, Var, Var, %A_SPACE%%A_SPACE%,%A_SPACE%,all	; the loops make sure that all of them are caught
	Loop, 300
		Stringreplace, Var, Var, `n,,all
	Loop, 300
		Stringreplace, Var, Var, `r,,all
	Var := regexreplace(Var, "^\s+")
	return
}
Clean(byref var){
	Stringreplace, var, var, %A_TAB%,%A_SPACE%,all
	Loop, 300
		Stringreplace, Var, Var, %A_SPACE%%A_SPACE%,%A_SPACE%,all
	Loop, 300
		Stringreplace, Var, Var, `n,,all
	Loop, 300
		Stringreplace, Var, Var, `r,,all
	Var := regexreplace(Var, "^\s+")
	return
}
getStyle(byref Style){
		Loop
		{
			tlist:= ["lavender","verdant","altitude","contrast","deepBlue"]
			
				sty:= tList[A_INDEX]
				
			ImageSearch, FoundX, FoundY,0 , 0, 450, 450, C:\AutoHotkey\Tapestry\%sty%\Navigation\basicInfoUp.BMP
				if ErrorLevel = 0
				{
					Style = epicIs%Sty%.BMP
					Break
				}
			ImageSearch, FoundX, FoundY,0 , 0, 450, 450, C:\AutoHotkey\Tapestry\%sty%\Navigation\basicInfoDown.BMP
				if ErrorLevel = 0
				{
					Style = epicIs%Sty%.BMP
					Break
				}	
		
				
			unterBrecher += 1
					if (unterBrecher > 300) {
						errorChecking = NO
						break
					}
		}
;-------------------------------------------------------------
	Stringreplace, Style, Style, `.bmp,,all
	StringReplace, Style, Style, epicIs,,all
		Global T = Style
			Stringreplace, T, T, `r`n,,all
			Stringreplace, t, t, %A_SPACE%,,all
			return
}	;-------End STYLE------------------------------------------------------
form(theme, sSwitch) { 
	unterBrecher = 0
		Loop
		{
			
			ImageSearch, X, Y,0 , 0, 234, 725, C:\AutoHotkey\Tapestry\%Theme%\navigation\basicInfoDown.BMP
				if ErrorLevel = 0
					Break
			unterBrecher += 1
				if (unterBrecher > 100) {
					errorChecking = NO
						msgbox an error has occurred.
					return
				}
			
			
			ImageSearch, X, Y,0 , 0, 234, 725, C:\AutoHotkey\Tapestry\%Theme%\navigation\basicInfoUp.BMP
				if ErrorLevel = 0
				{
					Mousemove,%X%,%Y%
					Sleep, 50
					Click, Left
				}
		}		
			Loop
			{

				ImageSearch, X, Y,0 , 0, 965, 307, C:\AutoHotkey\Tapestry\%Theme%\navigation\paperform.BMP
					if ErrorLevel = 0
					{
						y += -4
						Mousemove,%X%,%Y%
						Sleep, 50
						Click, Left
						break
					}
				ImageSearch, X, Y,0 , 0, 965, 307, C:\AutoHotkey\Tapestry\%Theme%\navigation\paperformLocked.BMP
					if ErrorLevel = 0
					{
						y += -4
						Mousemove,%X%,%Y%
						Sleep, 50
						Click, Left
						break
					}
				unterBrecher += 1
					if (unterBrecher > 10)
					{
						errorChecking = NO
						return
					}

			}
			
		
	Sleep, 1500



	sSwitch = YES
		If (sSwitch = "Yes")
		{
			Clipboard = 
			Sleep, 10
			mousemove, 446, 154
			Click, Left
			Sleep, 100
			if (type = "extra")
				Mousemove, 132, 183
			Else
				Mousemove, 147,163
			Click Down
			Sleep, 200
			Loop, 50
				Send, {WheelDown}
			Sleep, 300
			wingetpos, x, y, w, h, Hyperspace
			h += -105
			MOusemove, 753, %H%
			
			Sleep, 100
			Click Up
			if (type = "extra")
				Mousemove, 132, 183
			Else
				Mousemove, 147,163
			Click, Right
				Loop
				{
					ImageSearch, FoundX, FoundY, 0, 0, A_ScreenWidth, A_ScreenHeight,  C:\AutoHotkey\Tapestry\Generic\Coppers.BMP
						If Errorlevel = 0
							break
					ImageSearch, FoundX, FoundY, 0, 0, A_ScreenWidth, A_ScreenHeight,  C:\AutoHotkey\Tapestry\Generic\Copyg.BMP
						If Errorlevel = 0
							break
				}
			Sleep, 300
				Loop	
				{
					ImageSearch, FoundX, FoundY, 0, 0, A_ScreenWidth, A_ScreenHeight,  C:\AutoHotkey\Tapestry\Generic\Coppers.BMP
						If Errorlevel = 0
							break
					ImageSearch, FoundX, FoundY, 0, 0, A_ScreenWidth, A_ScreenHeight,  C:\AutoHotkey\Tapestry\Generic\Copyg.BMP
						If Errorlevel = 0
							break
				}
			Sleep, 300
			Clipboard = 
			Send, C
			ClipWait, 6
				If (Clipboard < 0)
				{
					gosub declarations
					msgbox an Error has occured.
					createGUI()
					return
				}
			xClip:= clipboard
			gosub ParseClaim
		}
}
navMain(nav, THEME) { 
	unterBrecher = 0
	Loop
	{
		ImageSearch, X, Y,0 , 0, 363, 725, C:\AutoHotkey\Tapestry\%Theme%\navigation\%nav%Down.BMP
			if ErrorLevel = 0
				break
		ImageSearch, X, Y,0 , 0, 363, 725, C:\AutoHotkey\Tapestry\%Theme%\navigation\%nav%Up.BMP
			if ErrorLevel = 0
				{
					X += 7
					Y += 7
					Mousemove,%X%,%Y%
					Click, Left
					Sleep, 10
				}	
		unterBrecher += 1
			if (unterBrecher > 200)
			{
				msgbox an error has occurred.
				errorChecking = NO
				return
			}
	}	
	return
}



ZipLoc(Byref Year, Byref Var, byRef loc){
	year:= fromDate[1]
	StringRight, year, year, 2
		If (year = 17 OR year = 18)
			Year = 2017
		If (Year = 16)
			Year = 2016
		if (Year = 2016)
			Fileread, Var, C:\AutoHotkey\Tapestry\Program Data\ZipTranslations2016.txt
		if (Year = 2017)
			Fileread, Var, C:\AutoHotkey\Tapestry\Program Data\ZipTranslations2017.txt

		ifnotinstring, var, `;%Zipcode%`,
		{
			Fileread, Var, C:\AutoHotkey\Tapestry\Program Data\genericstatezips.txt
				ifnotinstring, var, `;%Zipcode%`,
				{
					loc = ERROR
					return
				}
		}
	Trim(Var,Number)
	
	StringGetPos, number, var, %Zipcode%
	StringtrimLeft, var, var, %Number%
	StringGetPos, Number, var, `,
	Number += 1
	StringTrimleft, var, var, %number%
	StringGetPos, Number, var, `;
	StringLeft, var, var, %number%
	loc:= var
	
	
	return
	return
}
IEGet(Name="") {
	 IfEqual, Name,, WinGetTitle, Name, ahk_class IEFrame
		 Name := ( Name="New Tab - Windows Internet Explorer" ) ? "about:Tabs" 
		 : RegExReplace( Name, " - (Windows|Microsoft) Internet Explorer" )
	 For Pwb in ComObjCreate( "Shell.Application" ).Windows
		 If ( Pwb.LocationName = Name ) && InStr( Pwb.FullName, "iexplore.exe" )
			 Return Pwb
 } ;written by Jethrow
 IEGetbyURL(URL) {	; Provided by Learning one
    For pwb in ComObjCreate("Shell.Application").Windows
        If (instr(pwb.LocationURL,URL) and InStr(pwb.FullName, "iexplore.exe") > 0)
		{
			Return pwb
	}
}
dateFormat(dateVar) {
	Stringreplace, dateVar, dateVar, `/,,all
	yearChecker:= StrLen(dateVar)	; Check how many digits to decide whether to add leading 20 to year
		If (yearChecker = 8) {
			StringRight, dYear, dateVar, 4
			StringTrimRight, dateVar,dateVar, 4
		}
		If (yearChecker = 6) {
			StringRight, dYear, dateVar, 2
			StringTrimRight, dateVar, dateVar, 2
			dYear = 20%dYear%
		}
	dateVar =  %dYear%%dateVar% 		; reform variable with leading year
	outPutDate:= dateVar
	return
}
dateFormatWS(dateVar) {
	Stringreplace, dateVar, dateVar, `/,,all
	numChecker:= StrLen(dateVar)	; Check how many digits to decide whether to add leading 20 to year
		If (numChecker = 6) {
			StringRight, dYear, dateVar, 2
			StringTrimRight, dateVar, dateVar, 2
			dYear = 20%dYear%
			Stringleft, dMonth, dateVar, 2
			StringMid, dDay, dateVar, 3, 2
		}
		If (numChecker = 8) {
			StringRight, dYear, dateVar, 4
			StringTrimRight, dateVar, dateVar, 4
			Stringleft, dMonth, dateVar, 2
			StringMid, dDay, dateVar, 3, 2
		}
	dateVar =  %dMonth%/%dDay%/%dYear% 		; reform variable with leading year
	outPutDate:= dateVar
	return
}
wsBreak() {						; IE Error Handling
	msgbox An error has occured while trying to load the page. Please attempt to price the claim again.
	return
}
IEClose(ieWin) {				; IE Close+Error Handling
	unterBrecher = 0
		Loop
		{
			Ifwinexist, %ieWin%
				winclose, %ieWIN%
			ifwinnotexist, %ieWIN%
				break
			if (unterBrecher > 100)
				break
			unterBrecher += 1
			sleep, 1
		}
	if (unterBrecher > 100)
	{
		errorChecking = NO
		return
	}
else
errorChecking = YES
}	; End closeIE
SeiteBrecher(page, pgNum) {		; IE Error Handling
	unterBrecher = 0
	errorChecking = YES
		Loop	; Page is given time to load with a timeout
			{
			
			ifwinexist, %Page%
			break
			Sleep, 5
			unterBrecher += 1

			if (unterBrecher > pgNum)
				{
				errorChecking = NO
				break
				}
			}
} ; SeiteBrecher end
WartetKopie() {							; For Percent Calculations
	unterBrecher = 0
	brecher = 0
	Clipboard:= 
	arbeitsbereich= Winactive("A")
Loop
{
	
		IF (brecher > 2)
		{
			errorChecking = NO
			return
		}
		Loop,
		{
				ifwinactive, %arbeitsbereich%
					break
			unterBrecher += 1
				if (unterBrecher > 100)
					break
		}
	Click, Right		
	Loop
	{
		ImageSearch, X, Y,0, 0, 1500, 1500, C:\AutoHotkey\Tapestry\Generic\adjCopy.BMP	; Wait until menu appears
			if ErrorLevel = 0
				break
		ImageSearch, X, Y,0, 0, 1500, 1500, C:\AutoHotkey\Tapestry\Generic\adjReviewCopy.BMP	; Wait until menu appears
			if ErrorLevel = 0
				break		
			if (unterbrecher > 700){
				brecher += 1
				break
			}
		unterBrecher += 1
	}	
			unterBrecher = 0
			Sleep, 300
			Send, C
			Clipwait, 4
				ifnotinString, Clipboard, `.	; After 2 seconds, if a number (even 0.00) is not found
				{
					Send, {Escape}
					brecher += 1
				}
			
				if (clipboard > 0)
				{
					errorChecking = YES
					break
				}
				ifinstring, clipboard, `.
				{
					errorChecking = YES
					break
				}
}
					
	return
}

EM_SETCUEBANNER(hWnd, Cue) {
    return DllCall("user32.dll\SendMessage", "Ptr", hWnd, "UInt", 0x1501, "Ptr", 1, "Ptr", &Cue, "Ptr")
}




}	; END Functions



;AL01
;----------------------;START LIBRARIES----------------------------



; Gdip standard library v1.45 by tic (Tariq Porter) 07/09/11
; Modifed by Rseding91 using fincs 64 bit compatible Gdip library 5/1/2013
; Supports: Basic, _L ANSi, _L Unicode x86 and _L Unicode x64
;
; Updated 2/20/2014 - fixed Gdip_CreateRegion() and Gdip_GetClipRegion() on AHK Unicode x86
; Updated 5/13/2013 - fixed Gdip_SetBitmapToClipboard() on AHK Unicode x64
;
;#####################################################################################
;#####################################################################################
; STATUS ENUMERATION
; Return values for functions specified to have status enumerated return type
;#####################################################################################
;
; Ok =						= 0
; GenericError				= 1
; InvalidParameter			= 2
; OutOfMemory				= 3
; ObjectBusy				= 4
; InsufficientBuffer		= 5
; NotImplemented			= 6
; Win32Error				= 7
; WrongState				= 8
; Aborted					= 9
; FileNotFound				= 10
; ValueOverflow				= 11
; AccessDenied				= 12
; UnknownImageFormat		= 13
; FontFamilyNotFound		= 14
; FontStyleNotFound			= 15
; NotTrueTypeFont			= 16
; UnsupportedGdiplusVersion	= 17
; GdiplusNotInitialized		= 18
; PropertyNotFound			= 19
; PropertyNotSupported		= 20
; ProfileNotFound			= 21
;
;#####################################################################################
;#####################################################################################
; FUNCTIONS
;#####################################################################################
;
; UpdateLayeredWindow(hwnd, hdc, x="", y="", w="", h="", Alpha=255)
; BitBlt(ddc, dx, dy, dw, dh, sdc, sx, sy, Raster="")
; StretchBlt(dDC, dx, dy, dw, dh, sDC, sx, sy, sw, sh, Raster="")
; SetImage(hwnd, hBitmap)
; Gdip_BitmapFromScreen(Screen=0, Raster="")
; CreateRectF(ByRef RectF, x, y, w, h)
; CreateSizeF(ByRef SizeF, w, h)
; CreateDIBSection
;
;#####################################################################################

; Function:     			UpdateLayeredWindow
; Description:  			Updates a layered window with the handle to the DC of a gdi bitmap
; 
; hwnd        				Handle of the layered window to update
; hdc           			Handle to the DC of the GDI bitmap to update the window with
; Layeredx      			x position to place the window
; Layeredy      			y position to place the window
; Layeredw      			Width of the window
; Layeredh      			Height of the window
; Alpha         			Default = 255 : The transparency (0-255) to set the window transparency
;
; return      				If the function succeeds, the return value is nonzero
;
; notes						If x or y omitted, then layered window will use its current coordinates
;							If w or h omitted then current width and height will be used

UpdateLayeredWindow(hwnd, hdc, x="", y="", w="", h="", Alpha=255)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	if ((x != "") && (y != ""))
		VarSetCapacity(pt, 8), NumPut(x, pt, 0, "UInt"), NumPut(y, pt, 4, "UInt")

	if (w = "") ||(h = "")
		WinGetPos,,, w, h, ahk_id %hwnd%
   
	return DllCall("UpdateLayeredWindow"
					, Ptr, hwnd
					, Ptr, 0
					, Ptr, ((x = "") && (y = "")) ? 0 : &pt
					, "int64*", w|h<<32
					, Ptr, hdc
					, "int64*", 0
					, "uint", 0
					, "UInt*", Alpha<<16|1<<24
					, "uint", 2)
}

;#####################################################################################

; Function				BitBlt
; Description			The BitBlt function performs a bit-block transfer of the color data corresponding to a rectangle 
;						of pixels from the specified source device context into a destination device context.
;
; dDC					handle to destination DC
; dx					x-coord of destination upper-left corner
; dy					y-coord of destination upper-left corner
; dw					width of the area to copy
; dh					height of the area to copy
; sDC					handle to source DC
; sx					x-coordinate of source upper-left corner
; sy					y-coordinate of source upper-left corner
; Raster				raster operation code
;
; return				If the function succeeds, the return value is nonzero
;
; notes					If no raster operation is specified, then SRCCOPY is used, which copies the source directly to the destination rectangle
;
; BLACKNESS				= 0x00000042
; NOTSRCERASE			= 0x001100A6
; NOTSRCCOPY			= 0x00330008
; SRCERASE				= 0x00440328
; DSTINVERT				= 0x00550009
; PATINVERT				= 0x005A0049
; SRCINVERT				= 0x00660046
; SRCAND				= 0x008800C6
; MERGEPAINT			= 0x00BB0226
; MERGECOPY				= 0x00C000CA
; SRCCOPY				= 0x00CC0020
; SRCPAINT				= 0x00EE0086
; PATCOPY				= 0x00F00021
; PATPAINT				= 0x00FB0A09
; WHITENESS				= 0x00FF0062
; CAPTUREBLT			= 0x40000000
; NOMIRRORBITMAP		= 0x80000000

BitBlt(ddc, dx, dy, dw, dh, sdc, sx, sy, Raster="")
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdi32\BitBlt"
					, Ptr, dDC
					, "int", dx
					, "int", dy
					, "int", dw
					, "int", dh
					, Ptr, sDC
					, "int", sx
					, "int", sy
					, "uint", Raster ? Raster : 0x00CC0020)
}

;#####################################################################################

; Function				StretchBlt
; Description			The StretchBlt function copies a bitmap from a source rectangle into a destination rectangle, 
;						stretching or compressing the bitmap to fit the dimensions of the destination rectangle, if necessary.
;						The system stretches or compresses the bitmap according to the stretching mode currently set in the destination device context.
;
; ddc					handle to destination DC
; dx					x-coord of destination upper-left corner
; dy					y-coord of destination upper-left corner
; dw					width of destination rectangle
; dh					height of destination rectangle
; sdc					handle to source DC
; sx					x-coordinate of source upper-left corner
; sy					y-coordinate of source upper-left corner
; sw					width of source rectangle
; sh					height of source rectangle
; Raster				raster operation code
;
; return				If the function succeeds, the return value is nonzero
;
; notes					If no raster operation is specified, then SRCCOPY is used. It uses the same raster operations as BitBlt		

StretchBlt(ddc, dx, dy, dw, dh, sdc, sx, sy, sw, sh, Raster="")
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdi32\StretchBlt"
					, Ptr, ddc
					, "int", dx
					, "int", dy
					, "int", dw
					, "int", dh
					, Ptr, sdc
					, "int", sx
					, "int", sy
					, "int", sw
					, "int", sh
					, "uint", Raster ? Raster : 0x00CC0020)
}

;#####################################################################################

; Function				SetStretchBltMode
; Description			The SetStretchBltMode function sets the bitmap stretching mode in the specified device context
;
; hdc					handle to the DC
; iStretchMode			The stretching mode, describing how the target will be stretched
;
; return				If the function succeeds, the return value is the previous stretching mode. If it fails it will return 0
;
; STRETCH_ANDSCANS 		= 0x01
; STRETCH_ORSCANS 		= 0x02
; STRETCH_DELETESCANS 	= 0x03
; STRETCH_HALFTONE 		= 0x04

SetStretchBltMode(hdc, iStretchMode=4)
{
	return DllCall("gdi32\SetStretchBltMode"
					, A_PtrSize ? "UPtr" : "UInt", hdc
					, "int", iStretchMode)
}

;#####################################################################################

; Function				SetImage
; Description			Associates a new image with a static control
;
; hwnd					handle of the control to update
; hBitmap				a gdi bitmap to associate the static control with
;
; return				If the function succeeds, the return value is nonzero

SetImage(hwnd, hBitmap)
{
	SendMessage, 0x172, 0x0, hBitmap,, ahk_id %hwnd%
	E := ErrorLevel
	DeleteObject(E)
	return E
}

;#####################################################################################

; Function				SetSysColorToControl
; Description			Sets a solid colour to a control
;
; hwnd					handle of the control to update
; SysColor				A system colour to set to the control
;
; return				If the function succeeds, the return value is zero
;
; notes					A control must have the 0xE style set to it so it is recognised as a bitmap
;						By default SysColor=15 is used which is COLOR_3DFACE. This is the standard background for a control
;
; COLOR_3DDKSHADOW				= 21
; COLOR_3DFACE					= 15
; COLOR_3DHIGHLIGHT				= 20
; COLOR_3DHILIGHT				= 20
; COLOR_3DLIGHT					= 22
; COLOR_3DSHADOW				= 16
; COLOR_ACTIVEBORDER			= 10
; COLOR_ACTIVECAPTION			= 2
; COLOR_APPWORKSPACE			= 12
; COLOR_BACKGROUND				= 1
; COLOR_BTNFACE					= 15
; COLOR_BTNHIGHLIGHT			= 20
; COLOR_BTNHILIGHT				= 20
; COLOR_BTNSHADOW				= 16
; COLOR_BTNTEXT					= 18
; COLOR_CAPTIONTEXT				= 9
; COLOR_DESKTOP					= 1
; COLOR_GRADIENTACTIVECAPTION	= 27
; COLOR_GRADIENTINACTIVECAPTION	= 28
; COLOR_GRAYTEXT				= 17
; COLOR_HIGHLIGHT				= 13
; COLOR_HIGHLIGHTTEXT			= 14
; COLOR_HOTLIGHT				= 26
; COLOR_INACTIVEBORDER			= 11
; COLOR_INACTIVECAPTION			= 3
; COLOR_INACTIVECAPTIONTEXT		= 19
; COLOR_INFOBK					= 24
; COLOR_INFOTEXT				= 23
; COLOR_MENU					= 4
; COLOR_MENUHILIGHT				= 29
; COLOR_MENUBAR					= 30
; COLOR_MENUTEXT				= 7
; COLOR_SCROLLBAR				= 0
; COLOR_WINDOW					= 5
; COLOR_WINDOWFRAME				= 6
; COLOR_WINDOWTEXT				= 8

SetSysColorToControl(hwnd, SysColor=15)
{
   WinGetPos,,, w, h, ahk_id %hwnd%
   bc := DllCall("GetSysColor", "Int", SysColor, "UInt")
   pBrushClear := Gdip_BrushCreateSolid(0xff000000 | (bc >> 16 | bc & 0xff00 | (bc & 0xff) << 16))
   pBitmap := Gdip_CreateBitmap(w, h), G := Gdip_GraphicsFromImage(pBitmap)
   Gdip_FillRectangle(G, pBrushClear, 0, 0, w, h)
   hBitmap := Gdip_CreateHBITMAPFromBitmap(pBitmap)
   SetImage(hwnd, hBitmap)
   Gdip_DeleteBrush(pBrushClear)
   Gdip_DeleteGraphics(G), Gdip_DisposeImage(pBitmap), DeleteObject(hBitmap)
   return 0
}

;#####################################################################################

; Function				Gdip_BitmapFromScreen
; Description			Gets a gdi+ bitmap from the screen
;
; Screen				0 = All screens
;						Any numerical value = Just that screen
;						x|y|w|h = Take specific coordinates with a width and height
; Raster				raster operation code
;
; return      			If the function succeeds, the return value is a pointer to a gdi+ bitmap
;						-1:		one or more of x,y,w,h not passed properly
;
; notes					If no raster operation is specified, then SRCCOPY is used to the returned bitmap

Gdip_BitmapFromScreen(Screen=0, Raster="")
{
	if (Screen = 0)
	{
		Sysget, x, 76
		Sysget, y, 77	
		Sysget, w, 78
		Sysget, h, 79
	}
	else if (SubStr(Screen, 1, 5) = "hwnd:")
	{
		Screen := SubStr(Screen, 6)
		if !WinExist( "ahk_id " Screen)
			return -2
		WinGetPos,,, w, h, ahk_id %Screen%
		x := y := 0
		hhdc := GetDCEx(Screen, 3)
	}
	else if (Screen&1 != "")
	{
		Sysget, M, Monitor, %Screen%
		x := MLeft, y := MTop, w := MRight-MLeft, h := MBottom-MTop
	}
	else
	{
		StringSplit, S, Screen, |
		x := S1, y := S2, w := S3, h := S4
	}

	if (x = "") || (y = "") || (w = "") || (h = "")
		return -1

	chdc := CreateCompatibleDC(), hbm := CreateDIBSection(w, h, chdc), obm := SelectObject(chdc, hbm), hhdc := hhdc ? hhdc : GetDC()
	BitBlt(chdc, 0, 0, w, h, hhdc, x, y, Raster)
	ReleaseDC(hhdc)
	
	pBitmap := Gdip_CreateBitmapFromHBITMAP(hbm)
	SelectObject(chdc, obm), DeleteObject(hbm), DeleteDC(hhdc), DeleteDC(chdc)
	return pBitmap
}

;#####################################################################################

; Function				Gdip_BitmapFromHWND
; Description			Uses PrintWindow to get a handle to the specified window and return a bitmap from it
;
; hwnd					handle to the window to get a bitmap from
;
; return				If the function succeeds, the return value is a pointer to a gdi+ bitmap
;
; notes					Window must not be not minimised in order to get a handle to it's client area

Gdip_BitmapFromHWND(hwnd)
{
	WinGetPos,,, Width, Height, ahk_id %hwnd%
	hbm := CreateDIBSection(Width, Height), hdc := CreateCompatibleDC(), obm := SelectObject(hdc, hbm)
	PrintWindow(hwnd, hdc)
	pBitmap := Gdip_CreateBitmapFromHBITMAP(hbm)
	SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc)
	return pBitmap
}

;#####################################################################################

; Function    			CreateRectF
; Description			Creates a RectF object, containing a the coordinates and dimensions of a rectangle
;
; RectF       			Name to call the RectF object
; x            			x-coordinate of the upper left corner of the rectangle
; y            			y-coordinate of the upper left corner of the rectangle
; w            			Width of the rectangle
; h            			Height of the rectangle
;
; return      			No return value

CreateRectF(ByRef RectF, x, y, w, h)
{
   VarSetCapacity(RectF, 16)
   NumPut(x, RectF, 0, "float"), NumPut(y, RectF, 4, "float"), NumPut(w, RectF, 8, "float"), NumPut(h, RectF, 12, "float")
}

;#####################################################################################

; Function    			CreateRect
; Description			Creates a Rect object, containing a the coordinates and dimensions of a rectangle
;
; RectF       			Name to call the RectF object
; x            			x-coordinate of the upper left corner of the rectangle
; y            			y-coordinate of the upper left corner of the rectangle
; w            			Width of the rectangle
; h            			Height of the rectangle
;
; return      			No return value

CreateRect(ByRef Rect, x, y, w, h)
{
	VarSetCapacity(Rect, 16)
	NumPut(x, Rect, 0, "uint"), NumPut(y, Rect, 4, "uint"), NumPut(w, Rect, 8, "uint"), NumPut(h, Rect, 12, "uint")
}
;#####################################################################################

; Function		    	CreateSizeF
; Description			Creates a SizeF object, containing an 2 values
;
; SizeF         		Name to call the SizeF object
; w            			w-value for the SizeF object
; h            			h-value for the SizeF object
;
; return      			No Return value

CreateSizeF(ByRef SizeF, w, h)
{
   VarSetCapacity(SizeF, 8)
   NumPut(w, SizeF, 0, "float"), NumPut(h, SizeF, 4, "float")     
}
;#####################################################################################

; Function		    	CreatePointF
; Description			Creates a SizeF object, containing an 2 values
;
; SizeF         		Name to call the SizeF object
; w            			w-value for the SizeF object
; h            			h-value for the SizeF object
;
; return      			No Return value

CreatePointF(ByRef PointF, x, y)
{
   VarSetCapacity(PointF, 8)
   NumPut(x, PointF, 0, "float"), NumPut(y, PointF, 4, "float")     
}
;#####################################################################################

; Function				CreateDIBSection
; Description			The CreateDIBSection function creates a DIB (Device Independent Bitmap) that applications can write to directly
;
; w						width of the bitmap to create
; h						height of the bitmap to create
; hdc					a handle to the device context to use the palette from
; bpp					bits per pixel (32 = ARGB)
; ppvBits				A pointer to a variable that receives a pointer to the location of the DIB bit values
;
; return				returns a DIB. A gdi bitmap
;
; notes					ppvBits will receive the location of the pixels in the DIB

CreateDIBSection(w, h, hdc="", bpp=32, ByRef ppvBits=0)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	hdc2 := hdc ? hdc : GetDC()
	VarSetCapacity(bi, 40, 0)
	
	NumPut(w, bi, 4, "uint")
	, NumPut(h, bi, 8, "uint")
	, NumPut(40, bi, 0, "uint")
	, NumPut(1, bi, 12, "ushort")
	, NumPut(0, bi, 16, "uInt")
	, NumPut(bpp, bi, 14, "ushort")
	
	hbm := DllCall("CreateDIBSection"
					, Ptr, hdc2
					, Ptr, &bi
					, "uint", 0
					, A_PtrSize ? "UPtr*" : "uint*", ppvBits
					, Ptr, 0
					, "uint", 0, Ptr)

	if !hdc
		ReleaseDC(hdc2)
	return hbm
}

;#####################################################################################

; Function				PrintWindow
; Description			The PrintWindow function copies a visual window into the specified device context (DC), typically a printer DC
;
; hwnd					A handle to the window that will be copied
; hdc					A handle to the device context
; Flags					Drawing options
;
; return				If the function succeeds, it returns a nonzero value
;
; PW_CLIENTONLY			= 1

PrintWindow(hwnd, hdc, Flags=0)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("PrintWindow", Ptr, hwnd, Ptr, hdc, "uint", Flags)
}

;#####################################################################################

; Function				DestroyIcon
; Description			Destroys an icon and frees any memory the icon occupied
;
; hIcon					Handle to the icon to be destroyed. The icon must not be in use
;
; return				If the function succeeds, the return value is nonzero

DestroyIcon(hIcon)
{
	return DllCall("DestroyIcon", A_PtrSize ? "UPtr" : "UInt", hIcon)
}

;#####################################################################################

PaintDesktop(hdc)
{
	return DllCall("PaintDesktop", A_PtrSize ? "UPtr" : "UInt", hdc)
}

;#####################################################################################

CreateCompatibleBitmap(hdc, w, h)
{
	return DllCall("gdi32\CreateCompatibleBitmap", A_PtrSize ? "UPtr" : "UInt", hdc, "int", w, "int", h)
}

;#####################################################################################

; Function				CreateCompatibleDC
; Description			This function creates a memory device context (DC) compatible with the specified device
;
; hdc					Handle to an existing device context					
;
; return				returns the handle to a device context or 0 on failure
;
; notes					If this handle is 0 (by default), the function creates a memory device context compatible with the application's current screen

CreateCompatibleDC(hdc=0)
{
   return DllCall("CreateCompatibleDC", A_PtrSize ? "UPtr" : "UInt", hdc)
}

;#####################################################################################

; Function				SelectObject
; Description			The SelectObject function selects an object into the specified device context (DC). The new object replaces the previous object of the same type
;
; hdc					Handle to a DC
; hgdiobj				A handle to the object to be selected into the DC
;
; return				If the selected object is not a region and the function succeeds, the return value is a handle to the object being replaced
;
; notes					The specified object must have been created by using one of the following functions
;						Bitmap - CreateBitmap, CreateBitmapIndirect, CreateCompatibleBitmap, CreateDIBitmap, CreateDIBSection (A single bitmap cannot be selected into more than one DC at the same time)
;						Brush - CreateBrushIndirect, CreateDIBPatternBrush, CreateDIBPatternBrushPt, CreateHatchBrush, CreatePatternBrush, CreateSolidBrush
;						Font - CreateFont, CreateFontIndirect
;						Pen - CreatePen, CreatePenIndirect
;						Region - CombineRgn, CreateEllipticRgn, CreateEllipticRgnIndirect, CreatePolygonRgn, CreateRectRgn, CreateRectRgnIndirect
;
; notes					If the selected object is a region and the function succeeds, the return value is one of the following value
;
; SIMPLEREGION			= 2 Region consists of a single rectangle
; COMPLEXREGION			= 3 Region consists of more than one rectangle
; NULLREGION			= 1 Region is empty

SelectObject(hdc, hgdiobj)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("SelectObject", Ptr, hdc, Ptr, hgdiobj)
}

;#####################################################################################

; Function				DeleteObject
; Description			This function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object
;						After the object is deleted, the specified handle is no longer valid
;
; hObject				Handle to a logical pen, brush, font, bitmap, region, or palette to delete
;
; return				Nonzero indicates success. Zero indicates that the specified handle is not valid or that the handle is currently selected into a device context

DeleteObject(hObject)
{
   return DllCall("DeleteObject", A_PtrSize ? "UPtr" : "UInt", hObject)
}

;#####################################################################################

; Function				GetDC
; Description			This function retrieves a handle to a display device context (DC) for the client area of the specified window.
;						The display device context can be used in subsequent graphics display interface (GDI) functions to draw in the client area of the window. 
;
; hwnd					Handle to the window whose device context is to be retrieved. If this value is NULL, GetDC retrieves the device context for the entire screen					
;
; return				The handle the device context for the specified window's client area indicates success. NULL indicates failure

GetDC(hwnd=0)
{
	return DllCall("GetDC", A_PtrSize ? "UPtr" : "UInt", hwnd)
}

;#####################################################################################

; DCX_CACHE = 0x2
; DCX_CLIPCHILDREN = 0x8
; DCX_CLIPSIBLINGS = 0x10
; DCX_EXCLUDERGN = 0x40
; DCX_EXCLUDEUPDATE = 0x100
; DCX_INTERSECTRGN = 0x80
; DCX_INTERSECTUPDATE = 0x200
; DCX_LOCKWINDOWUPDATE = 0x400
; DCX_NORECOMPUTE = 0x100000
; DCX_NORESETATTRS = 0x4
; DCX_PARENTCLIP = 0x20
; DCX_VALIDATE = 0x200000
; DCX_WINDOW = 0x1

GetDCEx(hwnd, flags=0, hrgnClip=0)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
    return DllCall("GetDCEx", Ptr, hwnd, Ptr, hrgnClip, "int", flags)
}

;#####################################################################################

; Function				ReleaseDC
; Description			This function releases a device context (DC), freeing it for use by other applications. The effect of ReleaseDC depends on the type of device context
;
; hdc					Handle to the device context to be released
; hwnd					Handle to the window whose device context is to be released
;
; return				1 = released
;						0 = not released
;
; notes					The application must call the ReleaseDC function for each call to the GetWindowDC function and for each call to the GetDC function that retrieves a common device context
;						An application cannot use the ReleaseDC function to release a device context that was created by calling the CreateDC function; instead, it must use the DeleteDC function. 

ReleaseDC(hdc, hwnd=0)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("ReleaseDC", Ptr, hwnd, Ptr, hdc)
}

;#####################################################################################

; Function				DeleteDC
; Description			The DeleteDC function deletes the specified device context (DC)
;
; hdc					A handle to the device context
;
; return				If the function succeeds, the return value is nonzero
;
; notes					An application must not delete a DC whose handle was obtained by calling the GetDC function. Instead, it must call the ReleaseDC function to free the DC

DeleteDC(hdc)
{
   return DllCall("DeleteDC", A_PtrSize ? "UPtr" : "UInt", hdc)
}
;#####################################################################################

; Function				Gdip_LibraryVersion
; Description			Get the current library version
;
; return				the library version
;
; notes					This is useful for non compiled programs to ensure that a person doesn't run an old version when testing your scripts

Gdip_LibraryVersion()
{
	return 1.45
}

;#####################################################################################

; Function				Gdip_LibrarySubVersion
; Description			Get the current library sub version
;
; return				the library sub version
;
; notes					This is the sub-version currently maintained by Rseding91
Gdip_LibrarySubVersion()
{
	return 1.47
}

;#####################################################################################

; Function:    			Gdip_BitmapFromBRA
; Description: 			Gets a pointer to a gdi+ bitmap from a BRA file
;
; BRAFromMemIn			The variable for a BRA file read to memory
; File					The name of the file, or its number that you would like (This depends on alternate parameter)
; Alternate				Changes whether the File parameter is the file name or its number
;
; return      			If the function succeeds, the return value is a pointer to a gdi+ bitmap
;						-1 = The BRA variable is empty
;						-2 = The BRA has an incorrect header
;						-3 = The BRA has information missing
;						-4 = Could not find file inside the BRA

Gdip_BitmapFromBRA(ByRef BRAFromMemIn, File, Alternate=0)
{
	Static FName = "ObjRelease"
	
	if !BRAFromMemIn
		return -1
	Loop, Parse, BRAFromMemIn, `n
	{
		if (A_Index = 1)
		{
			StringSplit, Header, A_LoopField, |
			if (Header0 != 4 || Header2 != "BRA!")
				return -2
		}
		else if (A_Index = 2)
		{
			StringSplit, Info, A_LoopField, |
			if (Info0 != 3)
				return -3
		}
		else
			break
	}
	if !Alternate
		StringReplace, File, File, \, \\, All
	RegExMatch(BRAFromMemIn, "mi`n)^" (Alternate ? File "\|.+?\|(\d+)\|(\d+)" : "\d+\|" File "\|(\d+)\|(\d+)") "$", FileInfo)
	if !FileInfo
		return -4
	
	hData := DllCall("GlobalAlloc", "uint", 2, Ptr, FileInfo2, Ptr)
	pData := DllCall("GlobalLock", Ptr, hData, Ptr)
	DllCall("RtlMoveMemory", Ptr, pData, Ptr, &BRAFromMemIn+Info2+FileInfo1, Ptr, FileInfo2)
	DllCall("GlobalUnlock", Ptr, hData)
	DllCall("ole32\CreateStreamOnHGlobal", Ptr, hData, "int", 1, A_PtrSize ? "UPtr*" : "UInt*", pStream)
	DllCall("gdiplus\GdipCreateBitmapFromStream", Ptr, pStream, A_PtrSize ? "UPtr*" : "UInt*", pBitmap)
	If (A_PtrSize)
		%FName%(pStream)
	Else
		DllCall(NumGet(NumGet(1*pStream)+8), "uint", pStream)
	return pBitmap
}

;#####################################################################################

; Function				Gdip_DrawRectangle
; Description			This function uses a pen to draw the outline of a rectangle into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the top left of the rectangle
; y						y-coordinate of the top left of the rectangle
; w						width of the rectanlge
; h						height of the rectangle
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawRectangle(pGraphics, pPen, x, y, w, h)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipDrawRectangle", Ptr, pGraphics, Ptr, pPen, "float", x, "float", y, "float", w, "float", h)
}

;#####################################################################################

; Function				Gdip_DrawRoundedRectangle
; Description			This function uses a pen to draw the outline of a rounded rectangle into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the top left of the rounded rectangle
; y						y-coordinate of the top left of the rounded rectangle
; w						width of the rectanlge
; h						height of the rectangle
; r						radius of the rounded corners
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawRoundedRectangle(pGraphics, pPen, x, y, w, h, r)
{
	Gdip_SetClipRect(pGraphics, x-r, y-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x+w-r, y-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x-r, y+h-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x+w-r, y+h-r, 2*r, 2*r, 4)
	E := Gdip_DrawRectangle(pGraphics, pPen, x, y, w, h)
	Gdip_ResetClip(pGraphics)
	Gdip_SetClipRect(pGraphics, x-(2*r), y+r, w+(4*r), h-(2*r), 4)
	Gdip_SetClipRect(pGraphics, x+r, y-(2*r), w-(2*r), h+(4*r), 4)
	Gdip_DrawEllipse(pGraphics, pPen, x, y, 2*r, 2*r)
	Gdip_DrawEllipse(pGraphics, pPen, x+w-(2*r), y, 2*r, 2*r)
	Gdip_DrawEllipse(pGraphics, pPen, x, y+h-(2*r), 2*r, 2*r)
	Gdip_DrawEllipse(pGraphics, pPen, x+w-(2*r), y+h-(2*r), 2*r, 2*r)
	Gdip_ResetClip(pGraphics)
	return E
}

;#####################################################################################

; Function				Gdip_DrawEllipse
; Description			This function uses a pen to draw the outline of an ellipse into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the top left of the rectangle the ellipse will be drawn into
; y						y-coordinate of the top left of the rectangle the ellipse will be drawn into
; w						width of the ellipse
; h						height of the ellipse
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawEllipse(pGraphics, pPen, x, y, w, h)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipDrawEllipse", Ptr, pGraphics, Ptr, pPen, "float", x, "float", y, "float", w, "float", h)
}

;#####################################################################################

; Function				Gdip_DrawBezier
; Description			This function uses a pen to draw the outline of a bezier (a weighted curve) into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x1					x-coordinate of the start of the bezier
; y1					y-coordinate of the start of the bezier
; x2					x-coordinate of the first arc of the bezier
; y2					y-coordinate of the first arc of the bezier
; x3					x-coordinate of the second arc of the bezier
; y3					y-coordinate of the second arc of the bezier
; x4					x-coordinate of the end of the bezier
; y4					y-coordinate of the end of the bezier
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawBezier(pGraphics, pPen, x1, y1, x2, y2, x3, y3, x4, y4)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipDrawBezier"
					, Ptr, pgraphics
					, Ptr, pPen
					, "float", x1
					, "float", y1
					, "float", x2
					, "float", y2
					, "float", x3
					, "float", y3
					, "float", x4
					, "float", y4)
}

;#####################################################################################

; Function				Gdip_DrawArc
; Description			This function uses a pen to draw the outline of an arc into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the start of the arc
; y						y-coordinate of the start of the arc
; w						width of the arc
; h						height of the arc
; StartAngle			specifies the angle between the x-axis and the starting point of the arc
; SweepAngle			specifies the angle between the starting and ending points of the arc
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawArc(pGraphics, pPen, x, y, w, h, StartAngle, SweepAngle)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipDrawArc"
					, Ptr, pGraphics
					, Ptr, pPen
					, "float", x
					, "float", y
					, "float", w
					, "float", h
					, "float", StartAngle
					, "float", SweepAngle)
}

;#####################################################################################

; Function				Gdip_DrawPie
; Description			This function uses a pen to draw the outline of a pie into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x						x-coordinate of the start of the pie
; y						y-coordinate of the start of the pie
; w						width of the pie
; h						height of the pie
; StartAngle			specifies the angle between the x-axis and the starting point of the pie
; SweepAngle			specifies the angle between the starting and ending points of the pie
;
; return				status enumeration. 0 = success
;
; notes					as all coordinates are taken from the top left of each pixel, then the entire width/height should be specified as subtracting the pen width

Gdip_DrawPie(pGraphics, pPen, x, y, w, h, StartAngle, SweepAngle)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipDrawPie", Ptr, pGraphics, Ptr, pPen, "float", x, "float", y, "float", w, "float", h, "float", StartAngle, "float", SweepAngle)
}

;#####################################################################################

; Function				Gdip_DrawLine
; Description			This function uses a pen to draw a line into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; x1					x-coordinate of the start of the line
; y1					y-coordinate of the start of the line
; x2					x-coordinate of the end of the line
; y2					y-coordinate of the end of the line
;
; return				status enumeration. 0 = success		

Gdip_DrawLine(pGraphics, pPen, x1, y1, x2, y2)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipDrawLine"
					, Ptr, pGraphics
					, Ptr, pPen
					, "float", x1
					, "float", y1
					, "float", x2
					, "float", y2)
}

;#####################################################################################

; Function				Gdip_DrawLines
; Description			This function uses a pen to draw a series of joined lines into the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pPen					Pointer to a pen
; Points				the coordinates of all the points passed as x1,y1|x2,y2|x3,y3.....
;
; return				status enumeration. 0 = success				

Gdip_DrawLines(pGraphics, pPen, Points)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	StringSplit, Points, Points, |
	VarSetCapacity(PointF, 8*Points0)   
	Loop, %Points0%
	{
		StringSplit, Coord, Points%A_Index%, `,
		NumPut(Coord1, PointF, 8*(A_Index-1), "float"), NumPut(Coord2, PointF, (8*(A_Index-1))+4, "float")
	}
	return DllCall("gdiplus\GdipDrawLines", Ptr, pGraphics, Ptr, pPen, Ptr, &PointF, "int", Points0)
}

;#####################################################################################

; Function				Gdip_FillRectangle
; Description			This function uses a brush to fill a rectangle in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; x						x-coordinate of the top left of the rectangle
; y						y-coordinate of the top left of the rectangle
; w						width of the rectanlge
; h						height of the rectangle
;
; return				status enumeration. 0 = success

Gdip_FillRectangle(pGraphics, pBrush, x, y, w, h)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipFillRectangle"
					, Ptr, pGraphics
					, Ptr, pBrush
					, "float", x
					, "float", y
					, "float", w
					, "float", h)
}

;#####################################################################################

; Function				Gdip_FillRoundedRectangle
; Description			This function uses a brush to fill a rounded rectangle in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; x						x-coordinate of the top left of the rounded rectangle
; y						y-coordinate of the top left of the rounded rectangle
; w						width of the rectanlge
; h						height of the rectangle
; r						radius of the rounded corners
;
; return				status enumeration. 0 = success

Gdip_FillRoundedRectangle(pGraphics, pBrush, x, y, w, h, r)
{
	Region := Gdip_GetClipRegion(pGraphics)
	Gdip_SetClipRect(pGraphics, x-r, y-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x+w-r, y-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x-r, y+h-r, 2*r, 2*r, 4)
	Gdip_SetClipRect(pGraphics, x+w-r, y+h-r, 2*r, 2*r, 4)
	E := Gdip_FillRectangle(pGraphics, pBrush, x, y, w, h)
	Gdip_SetClipRegion(pGraphics, Region, 0)
	Gdip_SetClipRect(pGraphics, x-(2*r), y+r, w+(4*r), h-(2*r), 4)
	Gdip_SetClipRect(pGraphics, x+r, y-(2*r), w-(2*r), h+(4*r), 4)
	Gdip_FillEllipse(pGraphics, pBrush, x, y, 2*r, 2*r)
	Gdip_FillEllipse(pGraphics, pBrush, x+w-(2*r), y, 2*r, 2*r)
	Gdip_FillEllipse(pGraphics, pBrush, x, y+h-(2*r), 2*r, 2*r)
	Gdip_FillEllipse(pGraphics, pBrush, x+w-(2*r), y+h-(2*r), 2*r, 2*r)
	Gdip_SetClipRegion(pGraphics, Region, 0)
	Gdip_DeleteRegion(Region)
	return E
}

;#####################################################################################

; Function				Gdip_FillPolygon
; Description			This function uses a brush to fill a polygon in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; Points				the coordinates of all the points passed as x1,y1|x2,y2|x3,y3.....
;
; return				status enumeration. 0 = success
;
; notes					Alternate will fill the polygon as a whole, wheras winding will fill each new "segment"
; Alternate 			= 0
; Winding 				= 1

Gdip_FillPolygon(pGraphics, pBrush, Points, FillMode=0)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	StringSplit, Points, Points, |
	VarSetCapacity(PointF, 8*Points0)   
	Loop, %Points0%
	{
		StringSplit, Coord, Points%A_Index%, `,
		NumPut(Coord1, PointF, 8*(A_Index-1), "float"), NumPut(Coord2, PointF, (8*(A_Index-1))+4, "float")
	}   
	return DllCall("gdiplus\GdipFillPolygon", Ptr, pGraphics, Ptr, pBrush, Ptr, &PointF, "int", Points0, "int", FillMode)
}

;#####################################################################################

; Function				Gdip_FillPie
; Description			This function uses a brush to fill a pie in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; x						x-coordinate of the top left of the pie
; y						y-coordinate of the top left of the pie
; w						width of the pie
; h						height of the pie
; StartAngle			specifies the angle between the x-axis and the starting point of the pie
; SweepAngle			specifies the angle between the starting and ending points of the pie
;
; return				status enumeration. 0 = success

Gdip_FillPie(pGraphics, pBrush, x, y, w, h, StartAngle, SweepAngle)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipFillPie"
					, Ptr, pGraphics
					, Ptr, pBrush
					, "float", x
					, "float", y
					, "float", w
					, "float", h
					, "float", StartAngle
					, "float", SweepAngle)
}

;#####################################################################################

; Function				Gdip_FillEllipse
; Description			This function uses a brush to fill an ellipse in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; x						x-coordinate of the top left of the ellipse
; y						y-coordinate of the top left of the ellipse
; w						width of the ellipse
; h						height of the ellipse
;
; return				status enumeration. 0 = success

Gdip_FillEllipse(pGraphics, pBrush, x, y, w, h)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipFillEllipse", Ptr, pGraphics, Ptr, pBrush, "float", x, "float", y, "float", w, "float", h)
}

;#####################################################################################

; Function				Gdip_FillRegion
; Description			This function uses a brush to fill a region in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; Region				Pointer to a Region
;
; return				status enumeration. 0 = success
;
; notes					You can create a region Gdip_CreateRegion() and then add to this

Gdip_FillRegion(pGraphics, pBrush, Region)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipFillRegion", Ptr, pGraphics, Ptr, pBrush, Ptr, Region)
}

;#####################################################################################

; Function				Gdip_FillPath
; Description			This function uses a brush to fill a path in the Graphics of a bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBrush				Pointer to a brush
; Region				Pointer to a Path
;
; return				status enumeration. 0 = success

Gdip_FillPath(pGraphics, pBrush, Path)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipFillPath", Ptr, pGraphics, Ptr, pBrush, Ptr, Path)
}

;#####################################################################################

; Function				Gdip_DrawImagePointsRect
; Description			This function draws a bitmap into the Graphics of another bitmap and skews it
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBitmap				Pointer to a bitmap to be drawn
; Points				Points passed as x1,y1|x2,y2|x3,y3 (3 points: top left, top right, bottom left) describing the drawing of the bitmap
; sx					x-coordinate of source upper-left corner
; sy					y-coordinate of source upper-left corner
; sw					width of source rectangle
; sh					height of source rectangle
; Matrix				a matrix used to alter image attributes when drawing
;
; return				status enumeration. 0 = success
;
; notes					if sx,sy,sw,sh are missed then the entire source bitmap will be used
;						Matrix can be omitted to just draw with no alteration to ARGB
;						Matrix may be passed as a digit from 0 - 1 to change just transparency
;						Matrix can be passed as a matrix with any delimiter

Gdip_DrawImagePointsRect(pGraphics, pBitmap, Points, sx="", sy="", sw="", sh="", Matrix=1)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	StringSplit, Points, Points, |
	VarSetCapacity(PointF, 8*Points0)   
	Loop, %Points0%
	{
		StringSplit, Coord, Points%A_Index%, `,
		NumPut(Coord1, PointF, 8*(A_Index-1), "float"), NumPut(Coord2, PointF, (8*(A_Index-1))+4, "float")
	}

	if (Matrix&1 = "")
		ImageAttr := Gdip_SetImageAttributesColorMatrix(Matrix)
	else if (Matrix != 1)
		ImageAttr := Gdip_SetImageAttributesColorMatrix("1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|" Matrix "|0|0|0|0|0|1")
		
	if (sx = "" && sy = "" && sw = "" && sh = "")
	{
		sx := 0, sy := 0
		sw := Gdip_GetImageWidth(pBitmap)
		sh := Gdip_GetImageHeight(pBitmap)
	}

	E := DllCall("gdiplus\GdipDrawImagePointsRect"
				, Ptr, pGraphics
				, Ptr, pBitmap
				, Ptr, &PointF
				, "int", Points0
				, "float", sx
				, "float", sy
				, "float", sw
				, "float", sh
				, "int", 2
				, Ptr, ImageAttr
				, Ptr, 0
				, Ptr, 0)
	if ImageAttr
		Gdip_DisposeImageAttributes(ImageAttr)
	return E
}

;#####################################################################################

; Function				Gdip_DrawImage
; Description			This function draws a bitmap into the Graphics of another bitmap
;
; pGraphics				Pointer to the Graphics of a bitmap
; pBitmap				Pointer to a bitmap to be drawn
; dx					x-coord of destination upper-left corner
; dy					y-coord of destination upper-left corner
; dw					width of destination image
; dh					height of destination image
; sx					x-coordinate of source upper-left corner
; sy					y-coordinate of source upper-left corner
; sw					width of source image
; sh					height of source image
; Matrix				a matrix used to alter image attributes when drawing
;
; return				status enumeration. 0 = success
;
; notes					if sx,sy,sw,sh are missed then the entire source bitmap will be used
;						Gdip_DrawImage performs faster
;						Matrix can be omitted to just draw with no alteration to ARGB
;						Matrix may be passed as a digit from 0 - 1 to change just transparency
;						Matrix can be passed as a matrix with any delimiter. For example:
;						MatrixBright=
;						(
;						1.5		|0		|0		|0		|0
;						0		|1.5	|0		|0		|0
;						0		|0		|1.5	|0		|0
;						0		|0		|0		|1		|0
;						0.05	|0.05	|0.05	|0		|1
;						)
;
; notes					MatrixBright = 1.5|0|0|0|0|0|1.5|0|0|0|0|0|1.5|0|0|0|0|0|1|0|0.05|0.05|0.05|0|1
;						MatrixGreyScale = 0.299|0.299|0.299|0|0|0.587|0.587|0.587|0|0|0.114|0.114|0.114|0|0|0|0|0|1|0|0|0|0|0|1
;						MatrixNegative = -1|0|0|0|0|0|-1|0|0|0|0|0|-1|0|0|0|0|0|1|0|0|0|0|0|1

Gdip_DrawImage(pGraphics, pBitmap, dx="", dy="", dw="", dh="", sx="", sy="", sw="", sh="", Matrix=1)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	if (Matrix&1 = "")
		ImageAttr := Gdip_SetImageAttributesColorMatrix(Matrix)
	else if (Matrix != 1)
		ImageAttr := Gdip_SetImageAttributesColorMatrix("1|0|0|0|0|0|1|0|0|0|0|0|1|0|0|0|0|0|" Matrix "|0|0|0|0|0|1")

	if (sx = "" && sy = "" && sw = "" && sh = "")
	{
		if (dx = "" && dy = "" && dw = "" && dh = "")
		{
			sx := dx := 0, sy := dy := 0
			sw := dw := Gdip_GetImageWidth(pBitmap)
			sh := dh := Gdip_GetImageHeight(pBitmap)
		}
		else
		{
			sx := sy := 0
			sw := Gdip_GetImageWidth(pBitmap)
			sh := Gdip_GetImageHeight(pBitmap)
		}
	}

	E := DllCall("gdiplus\GdipDrawImageRectRect"
				, Ptr, pGraphics
				, Ptr, pBitmap
				, "float", dx
				, "float", dy
				, "float", dw
				, "float", dh
				, "float", sx
				, "float", sy
				, "float", sw
				, "float", sh
				, "int", 2
				, Ptr, ImageAttr
				, Ptr, 0
				, Ptr, 0)
	if ImageAttr
		Gdip_DisposeImageAttributes(ImageAttr)
	return E
}

;#####################################################################################

; Function				Gdip_SetImageAttributesColorMatrix
; Description			This function creates an image matrix ready for drawing
;
; Matrix				a matrix used to alter image attributes when drawing
;						passed with any delimeter
;
; return				returns an image matrix on sucess or 0 if it fails
;
; notes					MatrixBright = 1.5|0|0|0|0|0|1.5|0|0|0|0|0|1.5|0|0|0|0|0|1|0|0.05|0.05|0.05|0|1
;						MatrixGreyScale = 0.299|0.299|0.299|0|0|0.587|0.587|0.587|0|0|0.114|0.114|0.114|0|0|0|0|0|1|0|0|0|0|0|1
;						MatrixNegative = -1|0|0|0|0|0|-1|0|0|0|0|0|-1|0|0|0|0|0|1|0|0|0|0|0|1

Gdip_SetImageAttributesColorMatrix(Matrix)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	VarSetCapacity(ColourMatrix, 100, 0)
	Matrix := RegExReplace(RegExReplace(Matrix, "^[^\d-\.]+([\d\.])", "$1", "", 1), "[^\d-\.]+", "|")
	StringSplit, Matrix, Matrix, |
	Loop, 25
	{
		Matrix := (Matrix%A_Index% != "") ? Matrix%A_Index% : Mod(A_Index-1, 6) ? 0 : 1
		NumPut(Matrix, ColourMatrix, (A_Index-1)*4, "float")
	}
	DllCall("gdiplus\GdipCreateImageAttributes", A_PtrSize ? "UPtr*" : "uint*", ImageAttr)
	DllCall("gdiplus\GdipSetImageAttributesColorMatrix", Ptr, ImageAttr, "int", 1, "int", 1, Ptr, &ColourMatrix, Ptr, 0, "int", 0)
	return ImageAttr
}

;#####################################################################################

; Function				Gdip_GraphicsFromImage
; Description			This function gets the graphics for a bitmap used for drawing functions
;
; pBitmap				Pointer to a bitmap to get the pointer to its graphics
;
; return				returns a pointer to the graphics of a bitmap
;
; notes					a bitmap can be drawn into the graphics of another bitmap

Gdip_GraphicsFromImage(pBitmap)
{
	DllCall("gdiplus\GdipGetImageGraphicsContext", A_PtrSize ? "UPtr" : "UInt", pBitmap, A_PtrSize ? "UPtr*" : "UInt*", pGraphics)
	return pGraphics
}

;#####################################################################################

; Function				Gdip_GraphicsFromHDC
; Description			This function gets the graphics from the handle to a device context
;
; hdc					This is the handle to the device context
;
; return				returns a pointer to the graphics of a bitmap
;
; notes					You can draw a bitmap into the graphics of another bitmap

Gdip_GraphicsFromHDC(hdc)
{
    DllCall("gdiplus\GdipCreateFromHDC", A_PtrSize ? "UPtr" : "UInt", hdc, A_PtrSize ? "UPtr*" : "UInt*", pGraphics)
    return pGraphics
}

;#####################################################################################

; Function				Gdip_GetDC
; Description			This function gets the device context of the passed Graphics
;
; hdc					This is the handle to the device context
;
; return				returns the device context for the graphics of a bitmap

Gdip_GetDC(pGraphics)
{
	DllCall("gdiplus\GdipGetDC", A_PtrSize ? "UPtr" : "UInt", pGraphics, A_PtrSize ? "UPtr*" : "UInt*", hdc)
	return hdc
}

;#####################################################################################

; Function				Gdip_ReleaseDC
; Description			This function releases a device context from use for further use
;
; pGraphics				Pointer to the graphics of a bitmap
; hdc					This is the handle to the device context
;
; return				status enumeration. 0 = success

Gdip_ReleaseDC(pGraphics, hdc)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipReleaseDC", Ptr, pGraphics, Ptr, hdc)
}

;#####################################################################################

; Function				Gdip_GraphicsClear
; Description			Clears the graphics of a bitmap ready for further drawing
;
; pGraphics				Pointer to the graphics of a bitmap
; ARGB					The colour to clear the graphics to
;
; return				status enumeration. 0 = success
;
; notes					By default this will make the background invisible
;						Using clipping regions you can clear a particular area on the graphics rather than clearing the entire graphics

Gdip_GraphicsClear(pGraphics, ARGB=0x00ffffff)
{
    return DllCall("gdiplus\GdipGraphicsClear", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", ARGB)
}

;#####################################################################################

; Function				Gdip_BlurBitmap
; Description			Gives a pointer to a blurred bitmap from a pointer to a bitmap
;
; pBitmap				Pointer to a bitmap to be blurred
; Blur					The Amount to blur a bitmap by from 1 (least blur) to 100 (most blur)
;
; return				If the function succeeds, the return value is a pointer to the new blurred bitmap
;						-1 = The blur parameter is outside the range 1-100
;
; notes					This function will not dispose of the original bitmap

Gdip_BlurBitmap(pBitmap, Blur)
{
	if (Blur > 100) || (Blur < 1)
		return -1	
	
	sWidth := Gdip_GetImageWidth(pBitmap), sHeight := Gdip_GetImageHeight(pBitmap)
	dWidth := sWidth//Blur, dHeight := sHeight//Blur

	pBitmap1 := Gdip_CreateBitmap(dWidth, dHeight)
	G1 := Gdip_GraphicsFromImage(pBitmap1)
	Gdip_SetInterpolationMode(G1, 7)
	Gdip_DrawImage(G1, pBitmap, 0, 0, dWidth, dHeight, 0, 0, sWidth, sHeight)

	Gdip_DeleteGraphics(G1)

	pBitmap2 := Gdip_CreateBitmap(sWidth, sHeight)
	G2 := Gdip_GraphicsFromImage(pBitmap2)
	Gdip_SetInterpolationMode(G2, 7)
	Gdip_DrawImage(G2, pBitmap1, 0, 0, sWidth, sHeight, 0, 0, dWidth, dHeight)

	Gdip_DeleteGraphics(G2)
	Gdip_DisposeImage(pBitmap1)
	return pBitmap2
}

;#####################################################################################

; Function:     		Gdip_SaveBitmapToFile
; Description:  		Saves a bitmap to a file in any supported format onto disk
;   
; pBitmap				Pointer to a bitmap
; sOutput      			The name of the file that the bitmap will be saved to. Supported extensions are: .BMP,.DIB,.RLE,.JPG,.JPEG,.JPE,.JFIF,.GIF,.TIF,.TIFF,.PNG
; Quality      			If saving as jpg (.JPG,.JPEG,.JPE,.JFIF) then quality can be 1-100 with default at maximum quality
;
; return      			If the function succeeds, the return value is zero, otherwise:
;						-1 = Extension supplied is not a supported file format
;						-2 = Could not get a list of encoders on system
;						-3 = Could not find matching encoder for specified file format
;						-4 = Could not get WideChar name of output file
;						-5 = Could not save file to disk
;
; notes					This function will use the extension supplied from the sOutput parameter to determine the output format

Gdip_SaveBitmapToFile(pBitmap, sOutput, Quality=75)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	SplitPath, sOutput,,, Extension
	if Extension not in BMP,DIB,RLE,JPG,JPEG,JPE,JFIF,GIF,TIF,TIFF,PNG
		return -1
	Extension := "." Extension

	DllCall("gdiplus\GdipGetImageEncodersSize", "uint*", nCount, "uint*", nSize)
	VarSetCapacity(ci, nSize)
	DllCall("gdiplus\GdipGetImageEncoders", "uint", nCount, "uint", nSize, Ptr, &ci)
	if !(nCount && nSize)
		return -2
	
	If (A_IsUnicode){
		StrGet_Name := "StrGet"
		Loop, %nCount%
		{
			sString := %StrGet_Name%(NumGet(ci, (idx := (48+7*A_PtrSize)*(A_Index-1))+32+3*A_PtrSize), "UTF-16")
			if !InStr(sString, "*" Extension)
				continue
			
			pCodec := &ci+idx
			break
		}
	} else {
		Loop, %nCount%
		{
			Location := NumGet(ci, 76*(A_Index-1)+44)
			nSize := DllCall("WideCharToMultiByte", "uint", 0, "uint", 0, "uint", Location, "int", -1, "uint", 0, "int",  0, "uint", 0, "uint", 0)
			VarSetCapacity(sString, nSize)
			DllCall("WideCharToMultiByte", "uint", 0, "uint", 0, "uint", Location, "int", -1, "str", sString, "int", nSize, "uint", 0, "uint", 0)
			if !InStr(sString, "*" Extension)
				continue
			
			pCodec := &ci+76*(A_Index-1)
			break
		}
	}
	
	if !pCodec
		return -3

	if (Quality != 75)
	{
		Quality := (Quality < 0) ? 0 : (Quality > 100) ? 100 : Quality
		if Extension in .JPG,.JPEG,.JPE,.JFIF
		{
			DllCall("gdiplus\GdipGetEncoderParameterListSize", Ptr, pBitmap, Ptr, pCodec, "uint*", nSize)
			VarSetCapacity(EncoderParameters, nSize, 0)
			DllCall("gdiplus\GdipGetEncoderParameterList", Ptr, pBitmap, Ptr, pCodec, "uint", nSize, Ptr, &EncoderParameters)
			Loop, % NumGet(EncoderParameters, "UInt")      ;%
			{
				elem := (24+(A_PtrSize ? A_PtrSize : 4))*(A_Index-1) + 4 + (pad := A_PtrSize = 8 ? 4 : 0)
				if (NumGet(EncoderParameters, elem+16, "UInt") = 1) && (NumGet(EncoderParameters, elem+20, "UInt") = 6)
				{
					p := elem+&EncoderParameters-pad-4
					NumPut(Quality, NumGet(NumPut(4, NumPut(1, p+0)+20, "UInt")), "UInt")
					break
				}
			}      
		}
	}

	if (!A_IsUnicode)
	{
		nSize := DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sOutput, "int", -1, Ptr, 0, "int", 0)
		VarSetCapacity(wOutput, nSize*2)
		DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sOutput, "int", -1, Ptr, &wOutput, "int", nSize)
		VarSetCapacity(wOutput, -1)
		if !VarSetCapacity(wOutput)
			return -4
		E := DllCall("gdiplus\GdipSaveImageToFile", Ptr, pBitmap, Ptr, &wOutput, Ptr, pCodec, "uint", p ? p : 0)
	}
	else
		E := DllCall("gdiplus\GdipSaveImageToFile", Ptr, pBitmap, Ptr, &sOutput, Ptr, pCodec, "uint", p ? p : 0)
	return E ? -5 : 0
}

;#####################################################################################

; Function				Gdip_GetPixel
; Description			Gets the ARGB of a pixel in a bitmap
;
; pBitmap				Pointer to a bitmap
; x						x-coordinate of the pixel
; y						y-coordinate of the pixel
;
; return				Returns the ARGB value of the pixel

Gdip_GetPixel(pBitmap, x, y)
{
	DllCall("gdiplus\GdipBitmapGetPixel", A_PtrSize ? "UPtr" : "UInt", pBitmap, "int", x, "int", y, "uint*", ARGB)
	return ARGB
}

;#####################################################################################

; Function				Gdip_SetPixel
; Description			Sets the ARGB of a pixel in a bitmap
;
; pBitmap				Pointer to a bitmap
; x						x-coordinate of the pixel
; y						y-coordinate of the pixel
;
; return				status enumeration. 0 = success

Gdip_SetPixel(pBitmap, x, y, ARGB)
{
   return DllCall("gdiplus\GdipBitmapSetPixel", A_PtrSize ? "UPtr" : "UInt", pBitmap, "int", x, "int", y, "int", ARGB)
}

;#####################################################################################

; Function				Gdip_GetImageWidth
; Description			Gives the width of a bitmap
;
; pBitmap				Pointer to a bitmap
;
; return				Returns the width in pixels of the supplied bitmap

Gdip_GetImageWidth(pBitmap)
{
   DllCall("gdiplus\GdipGetImageWidth", A_PtrSize ? "UPtr" : "UInt", pBitmap, "uint*", Width)
   return Width
}

;#####################################################################################

; Function				Gdip_GetImageHeight
; Description			Gives the height of a bitmap
;
; pBitmap				Pointer to a bitmap
;
; return				Returns the height in pixels of the supplied bitmap

Gdip_GetImageHeight(pBitmap)
{
   DllCall("gdiplus\GdipGetImageHeight", A_PtrSize ? "UPtr" : "UInt", pBitmap, "uint*", Height)
   return Height
}

;#####################################################################################

; Function				Gdip_GetDimensions
; Description			Gives the width and height of a bitmap
;
; pBitmap				Pointer to a bitmap
; Width					ByRef variable. This variable will be set to the width of the bitmap
; Height				ByRef variable. This variable will be set to the height of the bitmap
;
; return				No return value
;						Gdip_GetDimensions(pBitmap, ThisWidth, ThisHeight) will set ThisWidth to the width and ThisHeight to the height

Gdip_GetImageDimensions(pBitmap, ByRef Width, ByRef Height)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	DllCall("gdiplus\GdipGetImageWidth", Ptr, pBitmap, "uint*", Width)
	DllCall("gdiplus\GdipGetImageHeight", Ptr, pBitmap, "uint*", Height)
}

;#####################################################################################

Gdip_GetDimensions(pBitmap, ByRef Width, ByRef Height)
{
	Gdip_GetImageDimensions(pBitmap, Width, Height)
}

;#####################################################################################

Gdip_GetImagePixelFormat(pBitmap)
{
	DllCall("gdiplus\GdipGetImagePixelFormat", A_PtrSize ? "UPtr" : "UInt", pBitmap, A_PtrSize ? "UPtr*" : "UInt*", Format)
	return Format
}

;#####################################################################################

; Function				Gdip_GetDpiX
; Description			Gives the horizontal dots per inch of the graphics of a bitmap
;
; pBitmap				Pointer to a bitmap
; Width					ByRef variable. This variable will be set to the width of the bitmap
; Height				ByRef variable. This variable will be set to the height of the bitmap
;
; return				No return value
;						Gdip_GetDimensions(pBitmap, ThisWidth, ThisHeight) will set ThisWidth to the width and ThisHeight to the height

Gdip_GetDpiX(pGraphics)
{
	DllCall("gdiplus\GdipGetDpiX", A_PtrSize ? "UPtr" : "uint", pGraphics, "float*", dpix)
	return Round(dpix)
}

;#####################################################################################

Gdip_GetDpiY(pGraphics)
{
	DllCall("gdiplus\GdipGetDpiY", A_PtrSize ? "UPtr" : "uint", pGraphics, "float*", dpiy)
	return Round(dpiy)
}

;#####################################################################################

Gdip_GetImageHorizontalResolution(pBitmap)
{
	DllCall("gdiplus\GdipGetImageHorizontalResolution", A_PtrSize ? "UPtr" : "uint", pBitmap, "float*", dpix)
	return Round(dpix)
}

;#####################################################################################

Gdip_GetImageVerticalResolution(pBitmap)
{
	DllCall("gdiplus\GdipGetImageVerticalResolution", A_PtrSize ? "UPtr" : "uint", pBitmap, "float*", dpiy)
	return Round(dpiy)
}

;#####################################################################################

Gdip_BitmapSetResolution(pBitmap, dpix, dpiy)
{
	return DllCall("gdiplus\GdipBitmapSetResolution", A_PtrSize ? "UPtr" : "uint", pBitmap, "float", dpix, "float", dpiy)
}

;#####################################################################################

Gdip_CreateBitmapFromFile(sFile, IconNumber=1, IconSize="")
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	, PtrA := A_PtrSize ? "UPtr*" : "UInt*"
	
	SplitPath, sFile,,, ext
	if ext in exe,dll
	{
		Sizes := IconSize ? IconSize : 256 "|" 128 "|" 64 "|" 48 "|" 32 "|" 16
		BufSize := 16 + (2*(A_PtrSize ? A_PtrSize : 4))
		
		VarSetCapacity(buf, BufSize, 0)
		Loop, Parse, Sizes, |
		{
			DllCall("PrivateExtractIcons", "str", sFile, "int", IconNumber-1, "int", A_LoopField, "int", A_LoopField, PtrA, hIcon, PtrA, 0, "uint", 1, "uint", 0)
			
			if !hIcon
				continue

			if !DllCall("GetIconInfo", Ptr, hIcon, Ptr, &buf)
			{
				DestroyIcon(hIcon)
				continue
			}
			
			hbmMask  := NumGet(buf, 12 + ((A_PtrSize ? A_PtrSize : 4) - 4))
			hbmColor := NumGet(buf, 12 + ((A_PtrSize ? A_PtrSize : 4) - 4) + (A_PtrSize ? A_PtrSize : 4))
			if !(hbmColor && DllCall("GetObject", Ptr, hbmColor, "int", BufSize, Ptr, &buf))
			{
				DestroyIcon(hIcon)
				continue
			}
			break
		}
		if !hIcon
			return -1

		Width := NumGet(buf, 4, "int"), Height := NumGet(buf, 8, "int")
		hbm := CreateDIBSection(Width, -Height), hdc := CreateCompatibleDC(), obm := SelectObject(hdc, hbm)
		if !DllCall("DrawIconEx", Ptr, hdc, "int", 0, "int", 0, Ptr, hIcon, "uint", Width, "uint", Height, "uint", 0, Ptr, 0, "uint", 3)
		{
			DestroyIcon(hIcon)
			return -2
		}
		
		VarSetCapacity(dib, 104)
		DllCall("GetObject", Ptr, hbm, "int", A_PtrSize = 8 ? 104 : 84, Ptr, &dib) ; sizeof(DIBSECTION) = 76+2*(A_PtrSize=8?4:0)+2*A_PtrSize
		Stride := NumGet(dib, 12, "Int"), Bits := NumGet(dib, 20 + (A_PtrSize = 8 ? 4 : 0)) ; padding
		DllCall("gdiplus\GdipCreateBitmapFromScan0", "int", Width, "int", Height, "int", Stride, "int", 0x26200A, Ptr, Bits, PtrA, pBitmapOld)
		pBitmap := Gdip_CreateBitmap(Width, Height)
		G := Gdip_GraphicsFromImage(pBitmap)
		, Gdip_DrawImage(G, pBitmapOld, 0, 0, Width, Height, 0, 0, Width, Height)
		SelectObject(hdc, obm), DeleteObject(hbm), DeleteDC(hdc)
		Gdip_DeleteGraphics(G), Gdip_DisposeImage(pBitmapOld)
		DestroyIcon(hIcon)
	}
	else
	{
		if (!A_IsUnicode)
		{
			VarSetCapacity(wFile, 1024)
			DllCall("kernel32\MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sFile, "int", -1, Ptr, &wFile, "int", 512)
			DllCall("gdiplus\GdipCreateBitmapFromFile", Ptr, &wFile, PtrA, pBitmap)
		}
		else
			DllCall("gdiplus\GdipCreateBitmapFromFile", Ptr, &sFile, PtrA, pBitmap)
	}
	
	return pBitmap
}

;#####################################################################################

Gdip_CreateBitmapFromHBITMAP(hBitmap, Palette=0)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	DllCall("gdiplus\GdipCreateBitmapFromHBITMAP", Ptr, hBitmap, Ptr, Palette, A_PtrSize ? "UPtr*" : "uint*", pBitmap)
	return pBitmap
}

;#####################################################################################

Gdip_CreateHBITMAPFromBitmap(pBitmap, Background=0xffffffff)
{
	DllCall("gdiplus\GdipCreateHBITMAPFromBitmap", A_PtrSize ? "UPtr" : "UInt", pBitmap, A_PtrSize ? "UPtr*" : "uint*", hbm, "int", Background)
	return hbm
}

;#####################################################################################

Gdip_CreateBitmapFromHICON(hIcon)
{
	DllCall("gdiplus\GdipCreateBitmapFromHICON", A_PtrSize ? "UPtr" : "UInt", hIcon, A_PtrSize ? "UPtr*" : "uint*", pBitmap)
	return pBitmap
}

;#####################################################################################

Gdip_CreateHICONFromBitmap(pBitmap)
{
	DllCall("gdiplus\GdipCreateHICONFromBitmap", A_PtrSize ? "UPtr" : "UInt", pBitmap, A_PtrSize ? "UPtr*" : "uint*", hIcon)
	return hIcon
}

;#####################################################################################

Gdip_CreateBitmap(Width, Height, Format=0x26200A)
{
    DllCall("gdiplus\GdipCreateBitmapFromScan0", "int", Width, "int", Height, "int", 0, "int", Format, A_PtrSize ? "UPtr" : "UInt", 0, A_PtrSize ? "UPtr*" : "uint*", pBitmap)
    Return pBitmap
}

;#####################################################################################

Gdip_CreateBitmapFromClipboard()
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	if !DllCall("OpenClipboard", Ptr, 0)
		return -1
	if !DllCall("IsClipboardFormatAvailable", "uint", 8)
		return -2
	if !hBitmap := DllCall("GetClipboardData", "uint", 2, Ptr)
		return -3
	if !pBitmap := Gdip_CreateBitmapFromHBITMAP(hBitmap)
		return -4
	if !DllCall("CloseClipboard")
		return -5
	DeleteObject(hBitmap)
	return pBitmap
}

;#####################################################################################

Gdip_SetBitmapToClipboard(pBitmap)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	off1 := A_PtrSize = 8 ? 52 : 44, off2 := A_PtrSize = 8 ? 32 : 24
	hBitmap := Gdip_CreateHBITMAPFromBitmap(pBitmap)
	DllCall("GetObject", Ptr, hBitmap, "int", VarSetCapacity(oi, A_PtrSize = 8 ? 104 : 84, 0), Ptr, &oi)
	hdib := DllCall("GlobalAlloc", "uint", 2, Ptr, 40+NumGet(oi, off1, "UInt"), Ptr)
	pdib := DllCall("GlobalLock", Ptr, hdib, Ptr)
	DllCall("RtlMoveMemory", Ptr, pdib, Ptr, &oi+off2, Ptr, 40)
	DllCall("RtlMoveMemory", Ptr, pdib+40, Ptr, NumGet(oi, off2 - (A_PtrSize ? A_PtrSize : 4), Ptr), Ptr, NumGet(oi, off1, "UInt"))
	DllCall("GlobalUnlock", Ptr, hdib)
	DllCall("DeleteObject", Ptr, hBitmap)
	DllCall("OpenClipboard", Ptr, 0)
	DllCall("EmptyClipboard")
	DllCall("SetClipboardData", "uint", 8, Ptr, hdib)
	DllCall("CloseClipboard")
}

;#####################################################################################

Gdip_CloneBitmapArea(pBitmap, x, y, w, h, Format=0x26200A)
{
	DllCall("gdiplus\GdipCloneBitmapArea"
					, "float", x
					, "float", y
					, "float", w
					, "float", h
					, "int", Format
					, A_PtrSize ? "UPtr" : "UInt", pBitmap
					, A_PtrSize ? "UPtr*" : "UInt*", pBitmapDest)
	return pBitmapDest
}

;#####################################################################################
; Create resources
;#####################################################################################

Gdip_CreatePen(ARGB, w)
{
   DllCall("gdiplus\GdipCreatePen1", "UInt", ARGB, "float", w, "int", 2, A_PtrSize ? "UPtr*" : "UInt*", pPen)
   return pPen
}

;#####################################################################################

Gdip_CreatePenFromBrush(pBrush, w)
{
	DllCall("gdiplus\GdipCreatePen2", A_PtrSize ? "UPtr" : "UInt", pBrush, "float", w, "int", 2, A_PtrSize ? "UPtr*" : "UInt*", pPen)
	return pPen
}

;#####################################################################################

Gdip_BrushCreateSolid(ARGB=0xff000000)
{
	DllCall("gdiplus\GdipCreateSolidFill", "UInt", ARGB, A_PtrSize ? "UPtr*" : "UInt*", pBrush)
	return pBrush
}

;#####################################################################################

; HatchStyleHorizontal = 0
; HatchStyleVertical = 1
; HatchStyleForwardDiagonal = 2
; HatchStyleBackwardDiagonal = 3
; HatchStyleCross = 4
; HatchStyleDiagonalCross = 5
; HatchStyle05Percent = 6
; HatchStyle10Percent = 7
; HatchStyle20Percent = 8
; HatchStyle25Percent = 9
; HatchStyle30Percent = 10
; HatchStyle40Percent = 11
; HatchStyle50Percent = 12
; HatchStyle60Percent = 13
; HatchStyle70Percent = 14
; HatchStyle75Percent = 15
; HatchStyle80Percent = 16
; HatchStyle90Percent = 17
; HatchStyleLightDownwardDiagonal = 18
; HatchStyleLightUpwardDiagonal = 19
; HatchStyleDarkDownwardDiagonal = 20
; HatchStyleDarkUpwardDiagonal = 21
; HatchStyleWideDownwardDiagonal = 22
; HatchStyleWideUpwardDiagonal = 23
; HatchStyleLightVertical = 24
; HatchStyleLightHorizontal = 25
; HatchStyleNarrowVertical = 26
; HatchStyleNarrowHorizontal = 27
; HatchStyleDarkVertical = 28
; HatchStyleDarkHorizontal = 29
; HatchStyleDashedDownwardDiagonal = 30
; HatchStyleDashedUpwardDiagonal = 31
; HatchStyleDashedHorizontal = 32
; HatchStyleDashedVertical = 33
; HatchStyleSmallConfetti = 34
; HatchStyleLargeConfetti = 35
; HatchStyleZigZag = 36
; HatchStyleWave = 37
; HatchStyleDiagonalBrick = 38
; HatchStyleHorizontalBrick = 39
; HatchStyleWeave = 40
; HatchStylePlaid = 41
; HatchStyleDivot = 42
; HatchStyleDottedGrid = 43
; HatchStyleDottedDiamond = 44
; HatchStyleShingle = 45
; HatchStyleTrellis = 46
; HatchStyleSphere = 47
; HatchStyleSmallGrid = 48
; HatchStyleSmallCheckerBoard = 49
; HatchStyleLargeCheckerBoard = 50
; HatchStyleOutlinedDiamond = 51
; HatchStyleSolidDiamond = 52
; HatchStyleTotal = 53
Gdip_BrushCreateHatch(ARGBfront, ARGBback, HatchStyle=0)
{
	DllCall("gdiplus\GdipCreateHatchBrush", "int", HatchStyle, "UInt", ARGBfront, "UInt", ARGBback, A_PtrSize ? "UPtr*" : "UInt*", pBrush)
	return pBrush
}

;#####################################################################################

Gdip_CreateTextureBrush(pBitmap, WrapMode=1, x=0, y=0, w="", h="")
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	, PtrA := A_PtrSize ? "UPtr*" : "UInt*"
	
	if !(w && h)
		DllCall("gdiplus\GdipCreateTexture", Ptr, pBitmap, "int", WrapMode, PtrA, pBrush)
	else
		DllCall("gdiplus\GdipCreateTexture2", Ptr, pBitmap, "int", WrapMode, "float", x, "float", y, "float", w, "float", h, PtrA, pBrush)
	return pBrush
}

;#####################################################################################

; WrapModeTile = 0
; WrapModeTileFlipX = 1
; WrapModeTileFlipY = 2
; WrapModeTileFlipXY = 3
; WrapModeClamp = 4
Gdip_CreateLineBrush(x1, y1, x2, y2, ARGB1, ARGB2, WrapMode=1)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	CreatePointF(PointF1, x1, y1), CreatePointF(PointF2, x2, y2)
	DllCall("gdiplus\GdipCreateLineBrush", Ptr, &PointF1, Ptr, &PointF2, "Uint", ARGB1, "Uint", ARGB2, "int", WrapMode, A_PtrSize ? "UPtr*" : "UInt*", LGpBrush)
	return LGpBrush
}

;#####################################################################################

; LinearGradientModeHorizontal = 0
; LinearGradientModeVertical = 1
; LinearGradientModeForwardDiagonal = 2
; LinearGradientModeBackwardDiagonal = 3
Gdip_CreateLineBrushFromRect(x, y, w, h, ARGB1, ARGB2, LinearGradientMode=1, WrapMode=1)
{
	CreateRectF(RectF, x, y, w, h)
	DllCall("gdiplus\GdipCreateLineBrushFromRect", A_PtrSize ? "UPtr" : "UInt", &RectF, "int", ARGB1, "int", ARGB2, "int", LinearGradientMode, "int", WrapMode, A_PtrSize ? "UPtr*" : "UInt*", LGpBrush)
	return LGpBrush
}

;#####################################################################################

Gdip_CloneBrush(pBrush)
{
	DllCall("gdiplus\GdipCloneBrush", A_PtrSize ? "UPtr" : "UInt", pBrush, A_PtrSize ? "UPtr*" : "UInt*", pBrushClone)
	return pBrushClone
}

;#####################################################################################
; Delete resources
;#####################################################################################

Gdip_DeletePen(pPen)
{
   return DllCall("gdiplus\GdipDeletePen", A_PtrSize ? "UPtr" : "UInt", pPen)
}

;#####################################################################################

Gdip_DeleteBrush(pBrush)
{
   return DllCall("gdiplus\GdipDeleteBrush", A_PtrSize ? "UPtr" : "UInt", pBrush)
}

;#####################################################################################

Gdip_DisposeImage(pBitmap)
{
   return DllCall("gdiplus\GdipDisposeImage", A_PtrSize ? "UPtr" : "UInt", pBitmap)
}

;#####################################################################################

Gdip_DeleteGraphics(pGraphics)
{
   return DllCall("gdiplus\GdipDeleteGraphics", A_PtrSize ? "UPtr" : "UInt", pGraphics)
}

;#####################################################################################

Gdip_DisposeImageAttributes(ImageAttr)
{
	return DllCall("gdiplus\GdipDisposeImageAttributes", A_PtrSize ? "UPtr" : "UInt", ImageAttr)
}

;#####################################################################################

Gdip_DeleteFont(hFont)
{
   return DllCall("gdiplus\GdipDeleteFont", A_PtrSize ? "UPtr" : "UInt", hFont)
}

;#####################################################################################

Gdip_DeleteStringFormat(hFormat)
{
   return DllCall("gdiplus\GdipDeleteStringFormat", A_PtrSize ? "UPtr" : "UInt", hFormat)
}

;#####################################################################################

Gdip_DeleteFontFamily(hFamily)
{
   return DllCall("gdiplus\GdipDeleteFontFamily", A_PtrSize ? "UPtr" : "UInt", hFamily)
}

;#####################################################################################

Gdip_DeleteMatrix(Matrix)
{
   return DllCall("gdiplus\GdipDeleteMatrix", A_PtrSize ? "UPtr" : "UInt", Matrix)
}

;#####################################################################################
; Text functions
;#####################################################################################

Gdip_TextToGraphics(pGraphics, Text, Options, Font="Arial", Width="", Height="", Measure=0)
{
	IWidth := Width, IHeight:= Height
	
	RegExMatch(Options, "i)X([\-\d\.]+)(p*)", xpos)
	RegExMatch(Options, "i)Y([\-\d\.]+)(p*)", ypos)
	RegExMatch(Options, "i)W([\-\d\.]+)(p*)", Width)
	RegExMatch(Options, "i)H([\-\d\.]+)(p*)", Height)
	RegExMatch(Options, "i)C(?!(entre|enter))([a-f\d]+)", Colour)
	RegExMatch(Options, "i)Top|Up|Bottom|Down|vCentre|vCenter", vPos)
	RegExMatch(Options, "i)NoWrap", NoWrap)
	RegExMatch(Options, "i)R(\d)", Rendering)
	RegExMatch(Options, "i)S(\d+)(p*)", Size)

	if !Gdip_DeleteBrush(Gdip_CloneBrush(Colour2))
		PassBrush := 1, pBrush := Colour2
	
	if !(IWidth && IHeight) && (xpos2 || ypos2 || Width2 || Height2 || Size2)
		return -1

	Style := 0, Styles := "Regular|Bold|Italic|BoldItalic|Underline|Strikeout"
	Loop, Parse, Styles, |
	{
		if RegExMatch(Options, "\b" A_loopField)
		Style |= (A_LoopField != "StrikeOut") ? (A_Index-1) : 8
	}
  
	Align := 0, Alignments := "Near|Left|Centre|Center|Far|Right"
	Loop, Parse, Alignments, |
	{
		if RegExMatch(Options, "\b" A_loopField)
			Align |= A_Index//2.1      ; 0|0|1|1|2|2
	}

	xpos := (xpos1 != "") ? xpos2 ? IWidth*(xpos1/100) : xpos1 : 0
	ypos := (ypos1 != "") ? ypos2 ? IHeight*(ypos1/100) : ypos1 : 0
	Width := Width1 ? Width2 ? IWidth*(Width1/100) : Width1 : IWidth
	Height := Height1 ? Height2 ? IHeight*(Height1/100) : Height1 : IHeight
	if !PassBrush
		Colour := "0x" (Colour2 ? Colour2 : "ff000000")
	Rendering := ((Rendering1 >= 0) && (Rendering1 <= 5)) ? Rendering1 : 4
	Size := (Size1 > 0) ? Size2 ? IHeight*(Size1/100) : Size1 : 12

	hFamily := Gdip_FontFamilyCreate(Font)
	hFont := Gdip_FontCreate(hFamily, Size, Style)
	FormatStyle := NoWrap ? 0x4000 | 0x1000 : 0x4000
	hFormat := Gdip_StringFormatCreate(FormatStyle)
	pBrush := PassBrush ? pBrush : Gdip_BrushCreateSolid(Colour)
	if !(hFamily && hFont && hFormat && pBrush && pGraphics)
		return !pGraphics ? -2 : !hFamily ? -3 : !hFont ? -4 : !hFormat ? -5 : !pBrush ? -6 : 0
   
	CreateRectF(RC, xpos, ypos, Width, Height)
	Gdip_SetStringFormatAlign(hFormat, Align)
	Gdip_SetTextRenderingHint(pGraphics, Rendering)
	ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hFormat, RC)

	if vPos
	{
		StringSplit, ReturnRC, ReturnRC, |
		
		if (vPos = "vCentre") || (vPos = "vCenter")
			ypos += (Height-ReturnRC4)//2
		else if (vPos = "Top") || (vPos = "Up")
			ypos := 0
		else if (vPos = "Bottom") || (vPos = "Down")
			ypos := Height-ReturnRC4
		
		CreateRectF(RC, xpos, ypos, Width, ReturnRC4)
		ReturnRC := Gdip_MeasureString(pGraphics, Text, hFont, hFormat, RC)
	}

	if !Measure
		E := Gdip_DrawString(pGraphics, Text, hFont, hFormat, pBrush, RC)

	if !PassBrush
		Gdip_DeleteBrush(pBrush)
	Gdip_DeleteStringFormat(hFormat)   
	Gdip_DeleteFont(hFont)
	Gdip_DeleteFontFamily(hFamily)
	return E ? E : ReturnRC
}

;#####################################################################################

Gdip_DrawString(pGraphics, sString, hFont, hFormat, pBrush, ByRef RectF)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	if (!A_IsUnicode)
	{
		nSize := DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sString, "int", -1, Ptr, 0, "int", 0)
		VarSetCapacity(wString, nSize*2)
		DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sString, "int", -1, Ptr, &wString, "int", nSize)
	}
	
	return DllCall("gdiplus\GdipDrawString"
					, Ptr, pGraphics
					, Ptr, A_IsUnicode ? &sString : &wString
					, "int", -1
					, Ptr, hFont
					, Ptr, &RectF
					, Ptr, hFormat
					, Ptr, pBrush)
}

;#####################################################################################

Gdip_MeasureString(pGraphics, sString, hFont, hFormat, ByRef RectF)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	VarSetCapacity(RC, 16)
	if !A_IsUnicode
	{
		nSize := DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sString, "int", -1, "uint", 0, "int", 0)
		VarSetCapacity(wString, nSize*2)   
		DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &sString, "int", -1, Ptr, &wString, "int", nSize)
	}
	
	DllCall("gdiplus\GdipMeasureString"
					, Ptr, pGraphics
					, Ptr, A_IsUnicode ? &sString : &wString
					, "int", -1
					, Ptr, hFont
					, Ptr, &RectF
					, Ptr, hFormat
					, Ptr, &RC
					, "uint*", Chars
					, "uint*", Lines)
	
	return &RC ? NumGet(RC, 0, "float") "|" NumGet(RC, 4, "float") "|" NumGet(RC, 8, "float") "|" NumGet(RC, 12, "float") "|" Chars "|" Lines : 0
}

; Near = 0
; Center = 1
; Far = 2
Gdip_SetStringFormatAlign(hFormat, Align)
{
   return DllCall("gdiplus\GdipSetStringFormatAlign", A_PtrSize ? "UPtr" : "UInt", hFormat, "int", Align)
}

; StringFormatFlagsDirectionRightToLeft    = 0x00000001
; StringFormatFlagsDirectionVertical       = 0x00000002
; StringFormatFlagsNoFitBlackBox           = 0x00000004
; StringFormatFlagsDisplayFormatControl    = 0x00000020
; StringFormatFlagsNoFontFallback          = 0x00000400
; StringFormatFlagsMeasureTrailingSpaces   = 0x00000800
; StringFormatFlagsNoWrap                  = 0x00001000
; StringFormatFlagsLineLimit               = 0x00002000
; StringFormatFlagsNoClip                  = 0x00004000 
Gdip_StringFormatCreate(Format=0, Lang=0)
{
   DllCall("gdiplus\GdipCreateStringFormat", "int", Format, "int", Lang, A_PtrSize ? "UPtr*" : "UInt*", hFormat)
   return hFormat
}

; Regular = 0
; Bold = 1
; Italic = 2
; BoldItalic = 3
; Underline = 4
; Strikeout = 8
Gdip_FontCreate(hFamily, Size, Style=0)
{
   DllCall("gdiplus\GdipCreateFont", A_PtrSize ? "UPtr" : "UInt", hFamily, "float", Size, "int", Style, "int", 0, A_PtrSize ? "UPtr*" : "UInt*", hFont)
   return hFont
}

Gdip_FontFamilyCreate(Font)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	if (!A_IsUnicode)
	{
		nSize := DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &Font, "int", -1, "uint", 0, "int", 0)
		VarSetCapacity(wFont, nSize*2)
		DllCall("MultiByteToWideChar", "uint", 0, "uint", 0, Ptr, &Font, "int", -1, Ptr, &wFont, "int", nSize)
	}
	
	DllCall("gdiplus\GdipCreateFontFamilyFromName"
					, Ptr, A_IsUnicode ? &Font : &wFont
					, "uint", 0
					, A_PtrSize ? "UPtr*" : "UInt*", hFamily)
	
	return hFamily
}

;#####################################################################################
; Matrix functions
;#####################################################################################

Gdip_CreateAffineMatrix(m11, m12, m21, m22, x, y)
{
   DllCall("gdiplus\GdipCreateMatrix2", "float", m11, "float", m12, "float", m21, "float", m22, "float", x, "float", y, A_PtrSize ? "UPtr*" : "UInt*", Matrix)
   return Matrix
}

Gdip_CreateMatrix()
{
   DllCall("gdiplus\GdipCreateMatrix", A_PtrSize ? "UPtr*" : "UInt*", Matrix)
   return Matrix
}

;#####################################################################################
; GraphicsPath functions
;#####################################################################################

; Alternate = 0
; Winding = 1
Gdip_CreatePath(BrushMode=0)
{
	DllCall("gdiplus\GdipCreatePath", "int", BrushMode, A_PtrSize ? "UPtr*" : "UInt*", Path)
	return Path
}

Gdip_AddPathEllipse(Path, x, y, w, h)
{
	return DllCall("gdiplus\GdipAddPathEllipse", A_PtrSize ? "UPtr" : "UInt", Path, "float", x, "float", y, "float", w, "float", h)
}

Gdip_AddPathPolygon(Path, Points)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	StringSplit, Points, Points, |
	VarSetCapacity(PointF, 8*Points0)   
	Loop, %Points0%
	{
		StringSplit, Coord, Points%A_Index%, `,
		NumPut(Coord1, PointF, 8*(A_Index-1), "float"), NumPut(Coord2, PointF, (8*(A_Index-1))+4, "float")
	}   

	return DllCall("gdiplus\GdipAddPathPolygon", Ptr, Path, Ptr, &PointF, "int", Points0)
}

Gdip_DeletePath(Path)
{
	return DllCall("gdiplus\GdipDeletePath", A_PtrSize ? "UPtr" : "UInt", Path)
}

;#####################################################################################
; Quality functions
;#####################################################################################

; SystemDefault = 0
; SingleBitPerPixelGridFit = 1
; SingleBitPerPixel = 2
; AntiAliasGridFit = 3
; AntiAlias = 4
Gdip_SetTextRenderingHint(pGraphics, RenderingHint)
{
	return DllCall("gdiplus\GdipSetTextRenderingHint", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", RenderingHint)
}

; Default = 0
; LowQuality = 1
; HighQuality = 2
; Bilinear = 3
; Bicubic = 4
; NearestNeighbor = 5
; HighQualityBilinear = 6
; HighQualityBicubic = 7
Gdip_SetInterpolationMode(pGraphics, InterpolationMode)
{
   return DllCall("gdiplus\GdipSetInterpolationMode", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", InterpolationMode)
}

; Default = 0
; HighSpeed = 1
; HighQuality = 2
; None = 3
; AntiAlias = 4
Gdip_SetSmoothingMode(pGraphics, SmoothingMode)
{
   return DllCall("gdiplus\GdipSetSmoothingMode", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", SmoothingMode)
}

; CompositingModeSourceOver = 0 (blended)
; CompositingModeSourceCopy = 1 (overwrite)
Gdip_SetCompositingMode(pGraphics, CompositingMode=0)
{
   return DllCall("gdiplus\GdipSetCompositingMode", A_PtrSize ? "UPtr" : "UInt", pGraphics, "int", CompositingMode)
}

;#####################################################################################
; Extra functions
;#####################################################################################

Gdip_Startup()
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	if !DllCall("GetModuleHandle", "str", "gdiplus", Ptr)
		DllCall("LoadLibrary", "str", "gdiplus")
	VarSetCapacity(si, A_PtrSize = 8 ? 24 : 16, 0), si := Chr(1)
	DllCall("gdiplus\GdiplusStartup", A_PtrSize ? "UPtr*" : "uint*", pToken, Ptr, &si, Ptr, 0)
	return pToken
}

Gdip_Shutdown(pToken) {
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	DllCall("gdiplus\GdiplusShutdown", Ptr, pToken)
	if hModule := DllCall("GetModuleHandle", "str", "gdiplus", Ptr)
		DllCall("FreeLibrary", Ptr, hModule)
	return 0
}

; Prepend = 0; The new operation is applied before the old operation.
; Append = 1; The new operation is applied after the old operation.
Gdip_RotateWorldTransform(pGraphics, Angle, MatrixOrder=0)
{
	return DllCall("gdiplus\GdipRotateWorldTransform", A_PtrSize ? "UPtr" : "UInt", pGraphics, "float", Angle, "int", MatrixOrder)
}

Gdip_ScaleWorldTransform(pGraphics, x, y, MatrixOrder=0)
{
	return DllCall("gdiplus\GdipScaleWorldTransform", A_PtrSize ? "UPtr" : "UInt", pGraphics, "float", x, "float", y, "int", MatrixOrder)
}

Gdip_TranslateWorldTransform(pGraphics, x, y, MatrixOrder=0)
{
	return DllCall("gdiplus\GdipTranslateWorldTransform", A_PtrSize ? "UPtr" : "UInt", pGraphics, "float", x, "float", y, "int", MatrixOrder)
}

Gdip_ResetWorldTransform(pGraphics)
{
	return DllCall("gdiplus\GdipResetWorldTransform", A_PtrSize ? "UPtr" : "UInt", pGraphics)
}

Gdip_GetRotatedTranslation(Width, Height, Angle, ByRef xTranslation, ByRef yTranslation)
{
	pi := 3.14159, TAngle := Angle*(pi/180)	

	Bound := (Angle >= 0) ? Mod(Angle, 360) : 360-Mod(-Angle, -360)
	if ((Bound >= 0) && (Bound <= 90))
		xTranslation := Height*Sin(TAngle), yTranslation := 0
	else if ((Bound > 90) && (Bound <= 180))
		xTranslation := (Height*Sin(TAngle))-(Width*Cos(TAngle)), yTranslation := -Height*Cos(TAngle)
	else if ((Bound > 180) && (Bound <= 270))
		xTranslation := -(Width*Cos(TAngle)), yTranslation := -(Height*Cos(TAngle))-(Width*Sin(TAngle))
	else if ((Bound > 270) && (Bound <= 360))
		xTranslation := 0, yTranslation := -Width*Sin(TAngle)
}

Gdip_GetRotatedDimensions(Width, Height, Angle, ByRef RWidth, ByRef RHeight)
{
	pi := 3.14159, TAngle := Angle*(pi/180)
	if !(Width && Height)
		return -1
	RWidth := Ceil(Abs(Width*Cos(TAngle))+Abs(Height*Sin(TAngle)))
	RHeight := Ceil(Abs(Width*Sin(TAngle))+Abs(Height*Cos(Tangle)))
}

; RotateNoneFlipNone   = 0
; Rotate90FlipNone     = 1
; Rotate180FlipNone    = 2
; Rotate270FlipNone    = 3
; RotateNoneFlipX      = 4
; Rotate90FlipX        = 5
; Rotate180FlipX       = 6
; Rotate270FlipX       = 7
; RotateNoneFlipY      = Rotate180FlipX
; Rotate90FlipY        = Rotate270FlipX
; Rotate180FlipY       = RotateNoneFlipX
; Rotate270FlipY       = Rotate90FlipX
; RotateNoneFlipXY     = Rotate180FlipNone
; Rotate90FlipXY       = Rotate270FlipNone
; Rotate180FlipXY      = RotateNoneFlipNone
; Rotate270FlipXY      = Rotate90FlipNone 

Gdip_ImageRotateFlip(pBitmap, RotateFlipType=1)
{
	return DllCall("gdiplus\GdipImageRotateFlip", A_PtrSize ? "UPtr" : "UInt", pBitmap, "int", RotateFlipType)
}

; Replace = 0
; Intersect = 1
; Union = 2
; Xor = 3
; Exclude = 4
; Complement = 5
Gdip_SetClipRect(pGraphics, x, y, w, h, CombineMode=0)
{
   return DllCall("gdiplus\GdipSetClipRect",  A_PtrSize ? "UPtr" : "UInt", pGraphics, "float", x, "float", y, "float", w, "float", h, "int", CombineMode)
}

Gdip_SetClipPath(pGraphics, Path, CombineMode=0)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	return DllCall("gdiplus\GdipSetClipPath", Ptr, pGraphics, Ptr, Path, "int", CombineMode)
}

Gdip_ResetClip(pGraphics)
{
   return DllCall("gdiplus\GdipResetClip", A_PtrSize ? "UPtr" : "UInt", pGraphics)
}

Gdip_GetClipRegion(pGraphics)
{
	Region := Gdip_CreateRegion()
	DllCall("gdiplus\GdipGetClip", A_PtrSize ? "UPtr" : "UInt", pGraphics, "UInt*", Region)
	return Region
}

Gdip_SetClipRegion(pGraphics, Region, CombineMode=0)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("gdiplus\GdipSetClipRegion", Ptr, pGraphics, Ptr, Region, "int", CombineMode)
}

Gdip_CreateRegion()
{
	DllCall("gdiplus\GdipCreateRegion", "UInt*", Region)
	return Region
}

Gdip_DeleteRegion(Region)
{
	return DllCall("gdiplus\GdipDeleteRegion", A_PtrSize ? "UPtr" : "UInt", Region)
}

;#####################################################################################
; BitmapLockBits
;#####################################################################################

Gdip_LockBits(pBitmap, x, y, w, h, ByRef Stride, ByRef Scan0, ByRef BitmapData, LockMode = 3, PixelFormat = 0x26200a)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	CreateRect(Rect, x, y, w, h)
	VarSetCapacity(BitmapData, 16+2*(A_PtrSize ? A_PtrSize : 4), 0)
	E := DllCall("Gdiplus\GdipBitmapLockBits", Ptr, pBitmap, Ptr, &Rect, "uint", LockMode, "int", PixelFormat, Ptr, &BitmapData)
	Stride := NumGet(BitmapData, 8, "Int")
	Scan0 := NumGet(BitmapData, 16, Ptr)
	return E
}

;#####################################################################################

Gdip_UnlockBits(pBitmap, ByRef BitmapData)
{
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	return DllCall("Gdiplus\GdipBitmapUnlockBits", Ptr, pBitmap, Ptr, &BitmapData)
}

;#####################################################################################

Gdip_SetLockBitPixel(ARGB, Scan0, x, y, Stride)
{
	Numput(ARGB, Scan0+0, (x*4)+(y*Stride), "UInt")
}

;#####################################################################################

Gdip_GetLockBitPixel(Scan0, x, y, Stride)
{
	return NumGet(Scan0+0, (x*4)+(y*Stride), "UInt")
}

;#####################################################################################

Gdip_PixelateBitmap(pBitmap, ByRef pBitmapOut, BlockSize)
{
	static PixelateBitmap
	
	Ptr := A_PtrSize ? "UPtr" : "UInt"
	
	if (!PixelateBitmap)
	{
		if A_PtrSize != 8 ; x86 machine code
		MCode_PixelateBitmap =
		(LTrim Join
		558BEC83EC3C8B4514538B5D1C99F7FB56578BC88955EC894DD885C90F8E830200008B451099F7FB8365DC008365E000894DC88955F08945E833FF897DD4
		397DE80F8E160100008BCB0FAFCB894DCC33C08945F88945FC89451C8945143BD87E608B45088D50028BC82BCA8BF02BF2418945F48B45E02955F4894DC4
		8D0CB80FAFCB03CA895DD08BD1895DE40FB64416030145140FB60201451C8B45C40FB604100145FC8B45F40FB604020145F883C204FF4DE475D6034D18FF
		4DD075C98B4DCC8B451499F7F98945148B451C99F7F989451C8B45FC99F7F98945FC8B45F899F7F98945F885DB7E648B450C8D50028BC82BCA83C103894D
		C48BC82BCA41894DF48B4DD48945E48B45E02955E48D0C880FAFCB03CA895DD08BD18BF38A45148B7DC48804178A451C8B7DF488028A45FC8804178A45F8
		8B7DE488043A83C2044E75DA034D18FF4DD075CE8B4DCC8B7DD447897DD43B7DE80F8CF2FEFFFF837DF0000F842C01000033C08945F88945FC89451C8945
		148945E43BD87E65837DF0007E578B4DDC034DE48B75E80FAF4D180FAFF38B45088D500203CA8D0CB18BF08BF88945F48B45F02BF22BFA2955F48945CC0F
		B6440E030145140FB60101451C0FB6440F010145FC8B45F40FB604010145F883C104FF4DCC75D8FF45E4395DE47C9B8B4DF00FAFCB85C9740B8B451499F7
		F9894514EB048365140033F63BCE740B8B451C99F7F989451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB
		038975F88975E43BDE7E5A837DF0007E4C8B4DDC034DE48B75E80FAF4D180FAFF38B450C8D500203CA8D0CB18BF08BF82BF22BFA2BC28B55F08955CC8A55
		1488540E038A551C88118A55FC88540F018A55F888140183C104FF4DCC75DFFF45E4395DE47CA68B45180145E0015DDCFF4DC80F8594FDFFFF8B451099F7
		FB8955F08945E885C00F8E450100008B45EC0FAFC38365DC008945D48B45E88945CC33C08945F88945FC89451C8945148945103945EC7E6085DB7E518B4D
		D88B45080FAFCB034D108D50020FAF4D18034DDC8BF08BF88945F403CA2BF22BFA2955F4895DC80FB6440E030145140FB60101451C0FB6440F010145FC8B
		45F40FB604080145F883C104FF4DC875D8FF45108B45103B45EC7CA08B4DD485C9740B8B451499F7F9894514EB048365140033F63BCE740B8B451C99F7F9
		89451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB038975F88975103975EC7E5585DB7E468B4DD88B450C
		0FAFCB034D108D50020FAF4D18034DDC8BF08BF803CA2BF22BFA2BC2895DC88A551488540E038A551C88118A55FC88540F018A55F888140183C104FF4DC8
		75DFFF45108B45103B45EC7CAB8BC3C1E0020145DCFF4DCC0F85CEFEFFFF8B4DEC33C08945F88945FC89451C8945148945103BC87E6C3945F07E5C8B4DD8
		8B75E80FAFCB034D100FAFF30FAF4D188B45088D500203CA8D0CB18BF08BF88945F48B45F02BF22BFA2955F48945C80FB6440E030145140FB60101451C0F
		B6440F010145FC8B45F40FB604010145F883C104FF4DC875D833C0FF45108B4DEC394D107C940FAF4DF03BC874068B451499F7F933F68945143BCE740B8B
		451C99F7F989451CEB0389751C3BCE740B8B45FC99F7F98945FCEB038975FC3BCE740B8B45F899F7F98945F8EB038975F88975083975EC7E63EB0233F639
		75F07E4F8B4DD88B75E80FAFCB034D080FAFF30FAF4D188B450C8D500203CA8D0CB18BF08BF82BF22BFA2BC28B55F08955108A551488540E038A551C8811
		8A55FC88540F018A55F888140883C104FF4D1075DFFF45088B45083B45EC7C9F5F5E33C05BC9C21800
		)
		else ; x64 machine code
		MCode_PixelateBitmap =
		(LTrim Join
		4489442418488954241048894C24085355565741544155415641574883EC28418BC1448B8C24980000004C8BDA99488BD941F7F9448BD0448BFA8954240C
		448994248800000085C00F8E9D020000418BC04533E4458BF299448924244C8954241041F7F933C9898C24980000008BEA89542404448BE889442408EB05
		4C8B5C24784585ED0F8E1A010000458BF1418BFD48897C2418450FAFF14533D233F633ED4533E44533ED4585C97E5B4C63BC2490000000418D040A410FAF
		C148984C8D441802498BD9498BD04D8BD90FB642010FB64AFF4403E80FB60203E90FB64AFE4883C2044403E003F149FFCB75DE4D03C748FFCB75D0488B7C
		24188B8C24980000004C8B5C2478418BC59941F7FE448BE8418BC49941F7FE448BE08BC59941F7FE8BE88BC69941F7FE8BF04585C97E4048639C24900000
		004103CA4D8BC1410FAFC94863C94A8D541902488BCA498BC144886901448821408869FF408871FE4883C10448FFC875E84803D349FFC875DA8B8C249800
		0000488B5C24704C8B5C24784183C20448FFCF48897C24180F850AFFFFFF8B6C2404448B2424448B6C24084C8B74241085ED0F840A01000033FF33DB4533
		DB4533D24533C04585C97E53488B74247085ED7E42438D0C04418BC50FAF8C2490000000410FAFC18D04814863C8488D5431028BCD0FB642014403D00FB6
		024883C2044403D80FB642FB03D80FB642FA03F848FFC975DE41FFC0453BC17CB28BCD410FAFC985C9740A418BC299F7F98BF0EB0233F685C9740B418BC3
		99F7F9448BD8EB034533DB85C9740A8BC399F7F9448BD0EB034533D285C9740A8BC799F7F9448BC0EB034533C033D24585C97E4D4C8B74247885ED7E3841
		8D0C14418BC50FAF8C2490000000410FAFC18D04814863C84A8D4431028BCD40887001448818448850FF448840FE4883C00448FFC975E8FFC2413BD17CBD
		4C8B7424108B8C2498000000038C2490000000488B5C24704503E149FFCE44892424898C24980000004C897424100F859EFDFFFF448B7C240C448B842480
		000000418BC09941F7F98BE8448BEA89942498000000896C240C85C00F8E3B010000448BAC2488000000418BCF448BF5410FAFC9898C248000000033FF33
		ED33F64533DB4533D24533C04585FF7E524585C97E40418BC5410FAFC14103C00FAF84249000000003C74898488D541802498BD90FB642014403D00FB602
		4883C2044403D80FB642FB03F00FB642FA03E848FFCB75DE488B5C247041FFC0453BC77CAE85C9740B418BC299F7F9448BE0EB034533E485C9740A418BC3
		99F7F98BD8EB0233DB85C9740A8BC699F7F9448BD8EB034533DB85C9740A8BC599F7F9448BD0EB034533D24533C04585FF7E4E488B4C24784585C97E3541
		8BC5410FAFC14103C00FAF84249000000003C74898488D540802498BC144886201881A44885AFF448852FE4883C20448FFC875E941FFC0453BC77CBE8B8C
		2480000000488B5C2470418BC1C1E00203F849FFCE0F85ECFEFFFF448BAC24980000008B6C240C448BA4248800000033FF33DB4533DB4533D24533C04585
		FF7E5A488B7424704585ED7E48418BCC8BC5410FAFC94103C80FAF8C2490000000410FAFC18D04814863C8488D543102418BCD0FB642014403D00FB60248
		83C2044403D80FB642FB03D80FB642FA03F848FFC975DE41FFC0453BC77CAB418BCF410FAFCD85C9740A418BC299F7F98BF0EB0233F685C9740B418BC399
		F7F9448BD8EB034533DB85C9740A8BC399F7F9448BD0EB034533D285C9740A8BC799F7F9448BC0EB034533C033D24585FF7E4E4585ED7E42418BCC8BC541
		0FAFC903CA0FAF8C2490000000410FAFC18D04814863C8488B442478488D440102418BCD40887001448818448850FF448840FE4883C00448FFC975E8FFC2
		413BD77CB233C04883C428415F415E415D415C5F5E5D5BC3
		)
		
		VarSetCapacity(PixelateBitmap, StrLen(MCode_PixelateBitmap)//2)
		Loop % StrLen(MCode_PixelateBitmap)//2		;%
			NumPut("0x" SubStr(MCode_PixelateBitmap, (2*A_Index)-1, 2), PixelateBitmap, A_Index-1, "UChar")
		DllCall("VirtualProtect", Ptr, &PixelateBitmap, Ptr, VarSetCapacity(PixelateBitmap), "uint", 0x40, A_PtrSize ? "UPtr*" : "UInt*", 0)
	}

	Gdip_GetImageDimensions(pBitmap, Width, Height)
	
	if (Width != Gdip_GetImageWidth(pBitmapOut) || Height != Gdip_GetImageHeight(pBitmapOut))
		return -1
	if (BlockSize > Width || BlockSize > Height)
		return -2

	E1 := Gdip_LockBits(pBitmap, 0, 0, Width, Height, Stride1, Scan01, BitmapData1)
	E2 := Gdip_LockBits(pBitmapOut, 0, 0, Width, Height, Stride2, Scan02, BitmapData2)
	if (E1 || E2)
		return -3

	E := DllCall(&PixelateBitmap, Ptr, Scan01, Ptr, Scan02, "int", Width, "int", Height, "int", Stride1, "int", BlockSize)
	
	Gdip_UnlockBits(pBitmap, BitmapData1), Gdip_UnlockBits(pBitmapOut, BitmapData2)
	return 0
}

;#####################################################################################

Gdip_ToARGB(A, R, G, B)
{
	return (A << 24) | (R << 16) | (G << 8) | B
}

;#####################################################################################

Gdip_FromARGB(ARGB, ByRef A, ByRef R, ByRef G, ByRef B)
{
	A := (0xff000000 & ARGB) >> 24
	R := (0x00ff0000 & ARGB) >> 16
	G := (0x0000ff00 & ARGB) >> 8
	B := 0x000000ff & ARGB
}

;#####################################################################################

Gdip_AFromARGB(ARGB)
{
	return (0xff000000 & ARGB) >> 24
}

;#####################################################################################

Gdip_RFromARGB(ARGB)
{
	return (0x00ff0000 & ARGB) >> 16
}

;#####################################################################################

Gdip_GFromARGB(ARGB)
{
	return (0x0000ff00 & ARGB) >> 8
}

;#####################################################################################

Gdip_BFromARGB(ARGB)
{
	return 0x000000ff & ARGB
}

;#####################################################################################

StrGetB(Address, Length=-1, Encoding=0)
{
	; Flexible parameter handling:
	if Length is not integer
	Encoding := Length,  Length := -1

	; Check for obvious errors.
	if (Address+0 < 1024)
		return

	; Ensure 'Encoding' contains a numeric identifier.
	if Encoding = UTF-16
		Encoding = 1200
	else if Encoding = UTF-8
		Encoding = 65001
	else if SubStr(Encoding,1,2)="CP"
		Encoding := SubStr(Encoding,3)

	if !Encoding ; "" or 0
	{
		; No conversion necessary, but we might not want the whole string.
		if (Length == -1)
			Length := DllCall("lstrlen", "uint", Address)
		VarSetCapacity(String, Length)
		DllCall("lstrcpyn", "str", String, "uint", Address, "int", Length + 1)
	}
	else if Encoding = 1200 ; UTF-16
	{
		char_count := DllCall("WideCharToMultiByte", "uint", 0, "uint", 0x400, "uint", Address, "int", Length, "uint", 0, "uint", 0, "uint", 0, "uint", 0)
		VarSetCapacity(String, char_count)
		DllCall("WideCharToMultiByte", "uint", 0, "uint", 0x400, "uint", Address, "int", Length, "str", String, "int", char_count, "uint", 0, "uint", 0)
	}
	else if Encoding is integer
	{
		; Convert from target encoding to UTF-16 then to the active code page.
		char_count := DllCall("MultiByteToWideChar", "uint", Encoding, "uint", 0, "uint", Address, "int", Length, "uint", 0, "int", 0)
		VarSetCapacity(String, char_count * 2)
		char_count := DllCall("MultiByteToWideChar", "uint", Encoding, "uint", 0, "uint", Address, "int", Length, "uint", &String, "int", char_count * 2)
		String := StrGetB(&String, char_count, 1200)
	}
	
	return String
}


;----------------------;End LIBRARIES----------------------------







